<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Physical Interaction Body Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 0;
      padding: 1rem;
      background: #f5f5f5;
    }

    h1 {
      font-size: 1.3rem;
      margin-bottom: 0.5rem;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: flex-start;
      margin-bottom: 1rem;
      padding: 1rem;
      background: white;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    label {
      font-size: 0.9rem;
      font-weight: 500;
    }

    input[type="text"],
    select {
      padding: 0.4rem 0.5rem;
      font-size: 0.9rem;
      border: 1px solid #ccc;
      border-radius: 0.3rem;
    }

    button {
      padding: 0.4rem 0.8rem;
      font-size: 0.9rem;
      cursor: pointer;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 0.3rem;
    }

    button:hover {
      background: #0056b3;
    }

    button.secondary {
      background: #6c757d;
    }

    button.secondary:hover {
      background: #545b62;
    }


    .figures {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .figure-wrapper {
      background: white;
      padding: 0.5rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      text-align: center;
    }

    .figure-label {
      font-size: 0.9rem;
      margin-bottom: 0.25rem;
      font-weight: 500;
    }

    canvas {
      border: 1px solid #ccc;
      touch-action: auto;
      cursor: crosshair;
    }

    .status {
      margin-top: 0.75rem;
      font-size: 0.85rem;
      color: #555;
    }

    .sync-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-left: 0.5rem;
      background: #ccc;
    }

    .sync-indicator.synced {
      background: #4CAF50;
    }

    .sync-indicator.syncing {
      background: #FFC107;
    }

    .sync-indicator.error {
      background: #f44336;
    }

    .id-status {
      font-size: 0.8rem;
      margin-top: 0.25rem;
      min-height: 1.2rem;
    }

    .id-valid {
      color: #4CAF50;
    }

    .id-invalid {
      color: #f44336;
    }

    /* Display Filter */
    .filter-container {
      position: sticky;
      top: 0;
      z-index: 100;
      background: white;
      padding: 1rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      margin-top: 2rem;
    }

    .filter-container h3 {
      margin-top: 0;
      margin-bottom: 1rem;
    }

    .filter-options {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .filter-options label {
      display: flex;
      align-items: flex-start;
      gap: 0.5rem;
      cursor: pointer;
      font-weight: 400;
      flex-wrap: wrap;
    }

    .filter-options input[type="radio"] {
      cursor: pointer;
      margin-top: 0.25rem;
      flex-shrink: 0;
    }

    .mode-hint {
      font-size: 0.75rem;
      color: #999;
      font-weight: normal;
      flex-basis: 100%;
      margin-left: 1.5rem;
    }

    .filter-preview {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 1px solid #333;
      margin-left: 0.5rem;
      flex-shrink: 0;
    }

    /* Points List */
    .points-list-container {
      background: white;
      padding: 1rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      margin-top: 2rem;
    }

    .points-list-container h3 {
      margin-top: 0;
      margin-bottom: 1rem;
    }

    .points-list {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #eee;
      border-radius: 0.3rem;
    }

    .point-item {
      padding: 0.75rem;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }

    .point-item:last-child {
      border-bottom: none;
    }

    .point-info {
      flex: 1;
      text-align: left;
      font-size: 0.85rem;
    }

    .point-color {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 1px solid #333;
    }

    .point-delete-btn {
      padding: 0.3rem 0.6rem;
      font-size: 0.8rem;
      background: #f44336;
      color: white;
      border: none;
      border-radius: 0.3rem;
      cursor: pointer;
    }

    .point-delete-btn:hover {
      background: #da190b;
    }

    .empty-list {
      padding: 1rem;
      text-align: center;
      color: #999;
      font-size: 0.9rem;
    }

    /* Confidence Level Section */
    .confidence-container {
      background: white;
      padding: 1rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      margin-top: 2rem;
    }

    .confidence-container h3 {
      margin-top: 0;
      margin-bottom: 1rem;
    }

    .confidence-content {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    /* Notes Section */
    .notes-container {
      background: white;
      padding: 1rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      margin-top: 2rem;
    }

    .notes-container h3 {
      margin-top: 0;
      margin-bottom: 1rem;
    }

    .notes-content {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .notes-content label {
      font-weight: 500;
      font-size: 0.95rem;
      margin-top: 0.5rem;
    }

    #sessionNotes {
      padding: 0.75rem;
      font-size: 0.9rem;
      border: 1px solid #ccc;
      border-radius: 0.3rem;
      font-family: system-ui, sans-serif;
      resize: vertical;
      min-height: 100px;
    }

    #sessionNotes:disabled {
      background: #f5f5f5;
      cursor: not-allowed;
      color: #999;
    }

    .char-counter {
      font-size: 0.8rem;
      color: #666;
      text-align: right;
    }

    .star-rating {
      display: flex;
      gap: 0.5rem;
      font-size: 2rem;
    }

    .star {
      cursor: pointer;
      color: #ddd;
      transition: color 0.2s;
      user-select: none;
    }

    .star:hover,
    .star.active {
      color: #ffc107;
    }

    .confidence-label {
      font-size: 0.85rem;
      color: #666;
      margin-top: -0.5rem;
    }

    .save-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: #999;
      margin-top: 0.5rem;
    }

    #noteSyncIndicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ccc;
    }

    #noteSyncIndicator.synced {
      background: #4CAF50;
    }

    #noteSyncIndicator.syncing {
      background: #FFC107;
    }

    #noteSyncIndicator.error {
      background: #f44336;
    }

    /* Questionnaire Section */
    .questionnaire-container {
      background: white;
      padding: 1rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      margin-top: 2rem;
    }

    .questionnaire-container h3 {
      margin-top: 0;
      margin-bottom: 1.5rem;
    }

    .questionnaire-content {
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    .questionnaire-question {
      padding: 1rem;
      border: 1px solid #eee;
      border-radius: 0.3rem;
      background: #fafafa;
    }

    .question-text {
      display: block;
      font-weight: 500;
      margin-bottom: 0.5rem;
      font-size: 0.95rem;
      line-height: 1.4;
      color: #333;
    }

    .scale-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #666;
      margin-bottom: 0.75rem;
      padding: 0 0.5rem;
    }

    .rating-scale {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-start;
    }

    .rating-scale input[type="radio"] {
      display: none;
    }

    .rating-scale label {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 35px;
      height: 35px;
      border: 2px solid #ddd;
      border-radius: 0.3rem;
      cursor: pointer;
      font-weight: 500;
      font-size: 0.9rem;
      transition: all 0.2s;
      background: white;
    }

    .rating-scale label:hover {
      border-color: #3498db;
      background: #f0f8ff;
    }

    .rating-scale input[type="radio"]:checked + label {
      background: #3498db;
      color: white;
      border-color: #3498db;
    }

    .questionnaire-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: #999;
      margin-top: 1rem;
    }

    #questionnaireSyncIndicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ccc;
    }

    #questionnaireSyncIndicator.synced {
      background: #4CAF50;
    }

    #questionnaireSyncIndicator.syncing {
      background: #FFC107;
    }

    #questionnaireSyncIndicator.error {
      background: #f44336;
    }
  </style>
</head>
<body>
  <h1>Physical Interaction Body Map</h1>

  <div class="controls">
    <div class="control-group">
      <label>Participant ID (must be a number):</label>
      <input type="text" id="participantId" placeholder="e.g. 001" />
      <div class="id-status" id="idStatus"></div>
    </div>

    <div class="control-group">
      <label>Participant Name:</label>
      <input type="text" id="participantName" placeholder="e.g. John" />
      <div class="id-status" id="nameStatus"></div>
    </div>

    <div class="control-group">
      <label>&nbsp;</label>
      <button id="clearPoints" class="secondary">Clear all points</button>
    </div>
  </div>

  <!-- Marking Mode -->
  <div class="filter-container">
    <div class="filter-options">
      <label>
        <input type="radio" name="markingMode" value="mark_touched_by" checked />
        Mark "I was touched" <span class="filter-preview" style="background: #e74c3c;"></span>
        <span class="mode-hint">(Records & Shows: I was touched)</span>
      </label>
      <label>
        <input type="radio" name="markingMode" value="mark_touched" />
        Mark "I touched" <span class="filter-preview" style="background: #3498db;"></span>
        <span class="mode-hint">(Records & Shows: I touched)</span>
      </label>
      <label>
        <input type="radio" name="markingMode" value="view_all" />
        View All Points
        <span class="mode-hint">(Viewing only - no recording)</span>
      </label>
    </div>
  </div>

  <div class="figures">
    <div class="figure-wrapper">
      <div class="figure-label">Front</div>
      <canvas id="figure_front" width="200" height="600"></canvas>
    </div>
    <div class="figure-wrapper">
      <div class="figure-label">Right</div>
      <canvas id="figure_right" width="100" height="600"></canvas>
    </div>
    <div class="figure-wrapper">
      <div class="figure-label">Back</div>
      <canvas id="figure_back" width="200" height="600"></canvas>
    </div>
    <div class="figure-wrapper">
      <div class="figure-label">Left</div>
      <canvas id="figure_left" width="100" height="600"></canvas>
    </div>
  </div>

  <div class="status" id="status">
    <span>Ready</span>
    <span class="sync-indicator" id="syncIndicator"></span>
  </div>

  <!-- Points List -->
  <div class="points-list-container">
    <h3>Recorded Points</h3>
    <div class="points-list" id="pointsList">
      <div class="empty-list">No points recorded yet</div>
    </div>
  </div>

  <!-- Questionnaire Section -->
  <div class="questionnaire-container">
    <h3>Questionnaire</h3>
    <div class="questionnaire-content">
      <!-- Question 1 -->
      <div class="questionnaire-question">
        <label class="question-text">
          How would you rate your confidence in the patterns you drew to represent the physical interaction you <strong>gave</strong>?
        </label>
        <div class="scale-labels">
          <span>0 = Not confident at all</span>
          <span>5 = Extremely confident</span>
        </div>
        <div class="rating-scale" id="q1Scale">
          <input type="radio" name="q1" value="0" id="q1_0"><label for="q1_0">0</label>
          <input type="radio" name="q1" value="1" id="q1_1"><label for="q1_1">1</label>
          <input type="radio" name="q1" value="2" id="q1_2"><label for="q1_2">2</label>
          <input type="radio" name="q1" value="3" id="q1_3"><label for="q1_3">3</label>
          <input type="radio" name="q1" value="4" id="q1_4"><label for="q1_4">4</label>
          <input type="radio" name="q1" value="5" id="q1_5"><label for="q1_5">5</label>
        </div>
      </div>

      <!-- Question 2 -->
      <div class="questionnaire-question">
        <label class="question-text">
          How would you rate your confidence in the patterns you drew to represent the physical interaction you <strong>received</strong>?
        </label>
        <div class="scale-labels">
          <span>0 = Not confident at all</span>
          <span>5 = Extremely confident</span>
        </div>
        <div class="rating-scale" id="q2Scale">
          <input type="radio" name="q2" value="0" id="q2_0"><label for="q2_0">0</label>
          <input type="radio" name="q2" value="1" id="q2_1"><label for="q2_1">1</label>
          <input type="radio" name="q2" value="2" id="q2_2"><label for="q2_2">2</label>
          <input type="radio" name="q2" value="3" id="q2_3"><label for="q2_3">3</label>
          <input type="radio" name="q2" value="4" id="q2_4"><label for="q2_4">4</label>
          <input type="radio" name="q2" value="5" id="q2_5"><label for="q2_5">5</label>
        </div>
      </div>

      <!-- Question 3 -->
      <div class="questionnaire-question">
        <label class="question-text">
          How would you rate your general awareness of contacts in crowded environments?
        </label>
        <div class="scale-labels">
          <span>0 = Never aware of physical interactions</span>
          <span>5 = Extremely aware</span>
        </div>
        <div class="rating-scale" id="q3Scale">
          <input type="radio" name="q3" value="0" id="q3_0"><label for="q3_0">0</label>
          <input type="radio" name="q3" value="1" id="q3_1"><label for="q3_1">1</label>
          <input type="radio" name="q3" value="2" id="q3_2"><label for="q3_2">2</label>
          <input type="radio" name="q3" value="3" id="q3_3"><label for="q3_3">3</label>
          <input type="radio" name="q3" value="4" id="q3_4"><label for="q3_4">4</label>
          <input type="radio" name="q3" value="5" id="q3_5"><label for="q3_5">5</label>
        </div>
      </div>

      <!-- Question 4 -->
      <div class="questionnaire-question">
        <label class="question-text">
          How would you rate your awareness of contacts during the experiments?
        </label>
        <div class="scale-labels">
          <span>0 = Never aware of physical interactions</span>
          <span>5 = Extremely aware</span>
        </div>
        <div class="rating-scale" id="q4Scale">
          <input type="radio" name="q4" value="0" id="q4_0"><label for="q4_0">0</label>
          <input type="radio" name="q4" value="1" id="q4_1"><label for="q4_1">1</label>
          <input type="radio" name="q4" value="2" id="q4_2"><label for="q4_2">2</label>
          <input type="radio" name="q4" value="3" id="q4_3"><label for="q4_3">3</label>
          <input type="radio" name="q4" value="4" id="q4_4"><label for="q4_4">4</label>
          <input type="radio" name="q4" value="5" id="q4_5"><label for="q4_5">5</label>
        </div>
      </div>

      <div class="questionnaire-status" id="questionnaireStatus">
        <span id="qLastSaved"></span>
        <span class="sync-indicator" id="questionnaireSyncIndicator"></span>
      </div>
    </div>
  </div>

  <!-- Overall Confidence Level Section -->
  <div class="confidence-container">
    <h3>Overall Confidence Level</h3>
    <div class="confidence-content">
      <div class="star-rating" id="starRating">
        <span class="star" data-value="1" title="Not confident">‚òÖ</span>
        <span class="star" data-value="2" title="Somewhat confident">‚òÖ</span>
        <span class="star" data-value="3" title="Moderately confident">‚òÖ</span>
        <span class="star" data-value="4" title="Confident">‚òÖ</span>
        <span class="star" data-value="5" title="Very confident">‚òÖ</span>
      </div>
      <div class="confidence-label" id="confidenceLabel">(Not rated)</div>

      <div class="save-status" id="saveStatus">
        <span id="lastSaved"></span>
        <span class="sync-indicator" id="noteSyncIndicator"></span>
      </div>
    </div>
  </div>

  <!-- Additional Comments Section -->
  <div class="notes-container">
    <h3>Additional Comments</h3>
    <div class="notes-content">
      <label for="sessionNotes">Comments (500 character limit):</label>
      <textarea 
        id="sessionNotes" 
        placeholder="Any additional comments about your declarations..."
        maxlength="500"
      ></textarea>
      <div class="char-counter">
        <span id="charCount">0</span>/500
      </div>

      <div class="save-status" id="saveStatus">
        <span id="lastSaved"></span>
        <span class="sync-indicator" id="noteSyncIndicator"></span>
      </div>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/11.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.0.0/firebase-database-compat.js"></script>

  <script>
    // ============ SESSION STATE CLASS ============
    class SessionState {
      constructor() {
        // Point collection
        this.collectedPoints = [];
        
        // Validation flags
        this.idIsValid = false;
        this.nameIsValid = false;
        
        // Session tracking
        this.isExistingSession = false;
        this.firstEntryTimestamp = null;
        this.canEdit = true;
        this.editStatusTimer = null;
        
        // Notes and confidence
        this.sessionNotes = "";
        this.sessionConfidence = 0;
        
        // Questionnaire responses
        this.questionnaireResponses = {
          q1: null,
          q2: null,
          q3: null,
          q4: null
        };
        
        // Marking mode and display
        this.markingMode = "mark_touched_by";
        this.currentDirection = "touched_by";
        this.displayFilter = "touched_by";
      }
      
      // Add point to collection (newest first)
      addPoint(point) {
        this.collectedPoints.unshift(point);
      }
      
      // Remove point by index
      removePoint(index) {
        this.collectedPoints.splice(index, 1);
      }
      
      // Clear all points
      clearAllPoints() {
        this.collectedPoints.length = 0;
      }
      
      // Check if session has any points of a specific direction
      hasPointsInDirection(direction) {
        return this.collectedPoints.some(p => p.direction === direction);
      }
      
      // Get total points count
      getPointsCount() {
        return this.collectedPoints.length;
      }
      
      // Set session notes and update confidence
      setSessionData(notes, confidence) {
        this.sessionNotes = notes;
        this.sessionConfidence = confidence;
      }
      
      // Set a questionnaire response
      setQuestionnaireResponse(questionKey, value) {
        if (this.questionnaireResponses.hasOwnProperty(questionKey)) {
          this.questionnaireResponses[questionKey] = value;
        }
      }
      
      // Get all unanswered questionnaire items
      getUnansweredItems() {
        return Object.entries(this.questionnaireResponses)
          .filter(([_, v]) => v === null)
          .map(([k]) => k);
      }
      
      // Set marking mode and update display accordingly
      setMarkingMode(mode) {
        this.markingMode = mode;
        
        if (mode === "mark_touched_by") {
          this.currentDirection = "touched_by";
          this.displayFilter = "touched_by";
        } else if (mode === "mark_touched") {
          this.currentDirection = "touched";
          this.displayFilter = "touched";
        } else if (mode === "view_all") {
          this.displayFilter = "all";
        }
      }
      
      // Reset entire session state
      reset() {
        this.collectedPoints = [];
        this.idIsValid = false;
        this.nameIsValid = false;
        this.isExistingSession = false;
        this.firstEntryTimestamp = null;
        this.canEdit = true;
        this.sessionNotes = "";
        this.sessionConfidence = 0;
        this.questionnaireResponses = {
          q1: null,
          q2: null,
          q3: null,
          q4: null
        };
        this.markingMode = "mark_touched_by";
        this.currentDirection = "touched_by";
        this.displayFilter = "touched_by";
        if (this.editStatusTimer) {
          clearInterval(this.editStatusTimer);
          this.editStatusTimer = null;
        }
      }
    }

    const appState = new SessionState();

    // ============ CUSTOM ERROR CLASSES ============
    class DataLoadError extends Error {
      constructor(message) {
        super(message);
        this.name = "DataLoadError";
      }
    }

    class DataSaveError extends Error {
      constructor(message) {
        super(message);
        this.name = "DataSaveError";
      }
    }

    class ValidationError extends Error {
      constructor(message) {
        super(message);
        this.name = "ValidationError";
      }
    }

    // ============ DATA SERVICE CLASS ============
    class DataService {
      constructor(firebaseDb) {
        this.db = firebaseDb;
        this.existingKeys = new Set();
      }

      // Validate participant ID (must be numeric)
      isValidNumericId(id) {
        return id && /^\d+$/.test(id);
      }

      // Validate participant name
      isValidName(name) {
        return name && name.trim().length > 0;
      }

      // Generate participant key from ID and name
      getParticipantKey(id, name) {
        return `${id}_${name.toLowerCase()}`;
      }

      // Check if participant key already exists
      keyAlreadyExists(id, name) {
        const key = this.getParticipantKey(id, name);
        return this.existingKeys.has(key);
      }

      // Load all existing participant keys from Firebase
      async loadExistingIds() {
        try {
          const snapshot = await this.db.ref("data").once("value");
          if (snapshot.exists()) {
            this.existingKeys = new Set(Object.keys(snapshot.val()));
            console.log("Loaded existing keys:", this.existingKeys);
          } else {
            console.log("Database is empty - ready for new sessions");
            this.existingKeys = new Set();
          }
        } catch (error) {
          const dataLoadError = new DataLoadError(`Failed to load existing participant keys: ${error.message}`);
          console.error(dataLoadError.name + ":", dataLoadError.message);
          this.existingKeys = new Set();
          // Continue gracefully - user can still add new data
        }
      }

      // Load existing participant session data from Firebase
      async loadExistingParticipantData(id, name) {
        try {
          const key = this.getParticipantKey(id, name);
          const snapshot = await this.db.ref(`data/${key}`).once("value");
          
          if (snapshot.exists()) {
            const data = snapshot.val();
            
            const points = Array.isArray(data.sessionPoints) ? data.sessionPoints : [];
            let earliestTimestamp = null;

            if (points.length > 0) {
              const sortedByTime = [...points].sort((a, b) => {
                const timeA = new Date(a.timestamp).getTime();
                const timeB = new Date(b.timestamp).getTime();
                return timeA - timeB;
              });
              earliestTimestamp = new Date(sortedByTime[0].timestamp).getTime();
            }

            // Return parsed data object (doesn't update state)
            return {
              exists: true,
              points: points,
              earliestTimestamp: earliestTimestamp,
              sessionData: data.sessionData || null
            };
          }

          return { exists: false };
        } catch (error) {
          const dataLoadError = new DataLoadError(`Failed to load participant data for ${id}_${name}: ${error.message}`);
          console.error(dataLoadError.name + ":", dataLoadError.message);
          throw dataLoadError;
        }
      }
    }

    // ============ IMAGE CACHE ============
    const imageCache = {};

    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyDt82k5jJTa9Xqn6Xb2-oEoVTHOr-wgvuA",
      authDomain: "body-map-9cdb6.firebaseapp.com",
      databaseURL: "https://body-map-9cdb6-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "body-map-9cdb6",
      storageBucket: "body-map-9cdb6.firebasestorage.app",
      messagingSenderId: "86071836780",
      appId: "1:86071836780:web:26ba38c4bfedf7d451d849",
      measurementId: "G-GQN61BV570"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const dataService = new DataService(db);

    // ============ COLOR MAPPING ============
    const directionColors = {
      touched: "#3498db",        // I touched - blue
      touched_by: "#e74c3c"      // I was touched - red
    };

    // ============ APP CODE ============
    const figureConfigs = [
      { id: "front", canvasId: "figure_front", imageSrc: "front.svg" },
      { id: "back",  canvasId: "figure_back",  imageSrc: "back.svg"  },
      { id: "left",  canvasId: "figure_left",  imageSrc: "left.svg"  },
      { id: "right", canvasId: "figure_right", imageSrc: "right.svg" },
    ];

    // DOM Elements (not state)
    const statusEl = document.getElementById("status");
    const syncIndicator = document.getElementById("syncIndicator");
    const participantInput = document.getElementById("participantId");
    const idStatusEl = document.getElementById("idStatus");
    const participantNameInput = document.getElementById("participantName");
    const nameStatusEl = document.getElementById("nameStatus");
    const pointsListEl = document.getElementById("pointsList");
    
    const EDIT_TIME_LIMIT = 60 * 60 * 1000;

    const notesTextarea = document.getElementById("sessionNotes");
    const starRating = document.getElementById("starRating");
    const confidenceLabel = document.getElementById("confidenceLabel");
    const charCountEl = document.getElementById("charCount");
    const lastSavedEl = document.getElementById("lastSaved");
    const noteSyncIndicator = document.getElementById("noteSyncIndicator");

    const questionnaireRadios = {
      q1: document.querySelectorAll('input[name="q1"]'),
      q2: document.querySelectorAll('input[name="q2"]'),
      q3: document.querySelectorAll('input[name="q3"]'),
      q4: document.querySelectorAll('input[name="q4"]')
    };
    const qLastSavedEl = document.getElementById("qLastSaved");
    const questionnaireSyncIndicator = document.getElementById("questionnaireSyncIndicator");

    const markingModeRadios = document.querySelectorAll('input[name="markingMode"]');

    // Firebase and State helpers

    // Load existing IDs from Firebase on startup
    // Load existing IDs from Firebase on startup
    async function loadExistingIds() {
      return await dataService.loadExistingIds();
    }

    function getParticipantKey(id, name) {
      return `${id}_${name.toLowerCase()}`;
    }

    function isValidNumericId(id) {
      return id && /^\d+$/.test(id);
    }

    function isValidName(name) {
      return name && name.trim().length > 0;
    }

    function keyAlreadyExists(id, name) {
      return dataService.keyAlreadyExists(id, name);
    }

    async function loadExistingParticipantData(id, name) {
      try {
        const result = await dataService.loadExistingParticipantData(id, name);
        
        if (result.exists) {
          appState.isExistingSession = true;
          appState.firstEntryTimestamp = result.earliestTimestamp;
          appState.collectedPoints = result.points;
          
          const now = Date.now();
          if (appState.firstEntryTimestamp !== null) {
            const elapsed = now - appState.firstEntryTimestamp;
            appState.canEdit = elapsed < EDIT_TIME_LIMIT;
          } else {
            appState.canEdit = true;
          }
          
          updatePointsList();
          redrawAllFigures();
          
          if (result.sessionData) {
            appState.sessionNotes = result.sessionData.notes || "";
            appState.sessionConfidence = result.sessionData.confidence || 0;
            appState.questionnaireResponses = result.sessionData.questionnaire || {
              q1: null,
              q2: null,
              q3: null,
              q4: null
            };
            updateNotesDisplay();
            updateQuestionnaireDisplay();
          } else {
            resetNotes();
            resetQuestionnaire();
          }
          
          updateEditStatus();
          startEditStatusTimer();
          updateNotesEditability();
          updateQuestionnaireEditability();
          
          return true;
        }
      } catch (error) {
        console.error("Error loading participant data:", error);
      }
      
      return false;
    }

    function updateEditStatus() {
      if (!appState.isExistingSession) {
        idStatusEl.textContent = "‚úì ID is valid";
        idStatusEl.className = "id-status id-valid";
        return;
      }

      if (appState.canEdit) {
        const elapsed = Date.now() - appState.firstEntryTimestamp;
        const remaining = EDIT_TIME_LIMIT - elapsed;
        
        if (remaining <= 0) {
          appState.canEdit = false;
          idStatusEl.textContent = "‚ùå Edit time limit expired (1 hour)";
          idStatusEl.className = "id-status id-invalid";
          return;
        }
        
        const minutesRemaining = Math.ceil(remaining / 60000);
        idStatusEl.textContent = `‚úì Editing enabled (${minutesRemaining} min remaining)`;
        idStatusEl.className = "id-status id-valid";
      } else {
        idStatusEl.textContent = "‚ùå Edit time limit expired (1 hour)";
        idStatusEl.className = "id-status id-invalid";
      }
    }

    let editStatusTimer = null;
    
    function startEditStatusTimer() {
      if (appState.editStatusTimer) clearInterval(appState.editStatusTimer);
      appState.editStatusTimer = setInterval(() => {
        if (appState.isExistingSession) {
          updateEditStatus();
        }
      }, 30000);
    }

    function stopEditStatusTimer() {
      if (appState.editStatusTimer) {
        clearInterval(appState.editStatusTimer);
        appState.editStatusTimer = null;
      }
    }

    function resetNotes() {
      appState.sessionNotes = "";
      appState.sessionConfidence = 0;
      notesTextarea.value = "";
      charCountEl.textContent = "0";
      confidenceLabel.textContent = "(Not rated)";
      document.querySelectorAll(".star").forEach(star => star.classList.remove("active"));
      lastSavedEl.textContent = "";
    }

    function updateNotesDisplay() {
      notesTextarea.value = appState.sessionNotes;
      charCountEl.textContent = appState.sessionNotes.length;
      updateStarsDisplay();
      updateNotesEditability();
    }

    function updateStarsDisplay() {
      document.querySelectorAll(".star").forEach(star => {
        const value = parseInt(star.dataset.value);
        if (value <= appState.sessionConfidence) {
          star.classList.add("active");
        } else {
          star.classList.remove("active");
        }
      });

      const labels = {
        0: "(Not rated)",
        1: "Not confident",
        2: "Somewhat confident",
        3: "Moderately confident",
        4: "Confident",
        5: "Very confident"
      };
      confidenceLabel.textContent = labels[appState.sessionConfidence] || "(Not rated)";
    }

    function updateNotesEditability() {
      const disabled = appState.isExistingSession && !appState.canEdit;
      notesTextarea.disabled = disabled;
      document.querySelectorAll(".star").forEach(star => {
        if (disabled) {
          star.style.pointerEvents = "none";
          star.style.opacity = "0.5";
        } else {
          star.style.pointerEvents = "auto";
          star.style.opacity = "1";
        }
      });
    }

    function updateCharCounter() {
      charCountEl.textContent = notesTextarea.value.length;
    }

    notesTextarea.addEventListener("input", (e) => {
      updateCharCounter();
    });

    document.querySelectorAll(".star").forEach(star => {
      star.addEventListener("click", (e) => {
        if (appState.isExistingSession && !appState.canEdit) return;
        
        appState.sessionConfidence = parseInt(e.target.dataset.value);
        updateStarsDisplay();
      });

      star.addEventListener("mouseover", (e) => {
        const value = parseInt(e.target.dataset.value);
        document.querySelectorAll(".star").forEach(s => {
          if (parseInt(s.dataset.value) <= value) {
            s.style.color = "#ffc107";
          } else {
            s.style.color = "#ddd";
          }
        });
      });
    });

    starRating.addEventListener("mouseleave", () => {
      updateStarsDisplay();
    });

    function resetQuestionnaire() {
      appState.questionnaireResponses = {
        q1: null,
        q2: null,
        q3: null,
        q4: null
      };
      Object.values(questionnaireRadios).forEach(radios => {
        radios.forEach(radio => radio.checked = false);
      });
      qLastSavedEl.textContent = "";
      updateQuestionnaireEditability();
    }

    function updateQuestionnaireDisplay() {
      Object.entries(appState.questionnaireResponses).forEach(([key, value]) => {
        if (value !== null) {
          const radio = document.querySelector(`input[name="${key}"][value="${value}"]`);
          if (radio) radio.checked = true;
        }
      });
      updateQuestionnaireEditability();
    }

    function updateQuestionnaireEditability() {
      const disabled = appState.isExistingSession && !appState.canEdit;
      Object.values(questionnaireRadios).forEach(radios => {
        radios.forEach(radio => {
          radio.disabled = disabled;
        });
      });
    }

    Object.entries(questionnaireRadios).forEach(([key, radios]) => {
      radios.forEach(radio => {
        radio.addEventListener("change", (e) => {
          if (appState.isExistingSession && !appState.canEdit) return;
          appState.setQuestionnaireResponse(key, parseInt(e.target.value));
        });
      });
    });

    function getFilteredPoints() {
      if (appState.displayFilter === "all") {
        return appState.collectedPoints;
      } else if (appState.displayFilter === "touched") {
        return appState.collectedPoints.filter(point => point.direction === "touched");
      } else if (appState.displayFilter === "touched_by") {
        return appState.collectedPoints.filter(point => point.direction === "touched_by");
      }
      return appState.collectedPoints;
    }

    function redrawAllFigures() {
      figureConfigs.forEach(redrawFigure);
    }

    // ============ IMAGE PRELOADING ============
    async function preloadImages() {
      return new Promise((resolve) => {
        let loadedCount = 0;
        const totalImages = figureConfigs.length;

        figureConfigs.forEach((figureConfig) => {
          const img = new Image();
          img.onload = () => {
            imageCache[figureConfig.id] = img;
            loadedCount++;
            if (loadedCount === totalImages) {
              console.log("All images preloaded successfully");
              resolve();
            }
          };
          img.onerror = () => {
            console.error(`Failed to load image: ${figureConfig.imageSrc}`);
            loadedCount++;
            if (loadedCount === totalImages) {
              resolve();
            }
          };
          img.src = figureConfig.imageSrc;
        });
      });
    }

    async function updateIdStatus() {
      const id = participantInput.value.trim();

      if (!id) {
        appState.idIsValid = false;
        idStatusEl.textContent = "";
        idStatusEl.className = "id-status";
        return;
      }

      if (!dataService.isValidNumericId(id)) {
        appState.idIsValid = false;
        const validationError = new ValidationError("Participant ID must be numeric (digits only)");
        console.warn(validationError.name + ":", validationError.message);
        idStatusEl.textContent = "‚ùå ID must be a number (digits only)";
        idStatusEl.className = "id-status id-invalid";
        return;
      }

      appState.idIsValid = true;
      idStatusEl.textContent = "‚úì ID is valid";
      idStatusEl.className = "id-status id-valid";
      
      updateCombinedKeyStatus();
    }

    async function updateNameStatus() {
      const name = participantNameInput.value.trim();

      if (!name) {
        appState.nameIsValid = false;
        nameStatusEl.textContent = "";
        nameStatusEl.className = "id-status";
        return;
      }

      if (!dataService.isValidName(name)) {
        appState.nameIsValid = false;
        const validationError = new ValidationError("Participant name must not be empty");
        console.warn(validationError.name + ":", validationError.message);
        nameStatusEl.textContent = "‚ùå Name must not be empty";
        nameStatusEl.className = "id-status id-invalid";
        return;
      }

      appState.nameIsValid = true;
      nameStatusEl.textContent = "‚úì Name is valid";
      nameStatusEl.className = "id-status id-valid";
      
      updateCombinedKeyStatus();
    }

    async function updateCombinedKeyStatus() {
      const id = participantInput.value.trim();
      const name = participantNameInput.value.trim();
      
      if (!appState.idIsValid || !appState.nameIsValid) {
        return;
      }

      const dataExists = await loadExistingParticipantData(id, name);
      
      if (!dataExists) {
        stopEditStatusTimer();
        appState.isExistingSession = false;
        appState.firstEntryTimestamp = null;
        appState.canEdit = true;
        appState.collectedPoints = [];
        updatePointsList();
        redrawAllFigures();
        resetNotes();
        resetQuestionnaire();
        updateNotesEditability();
        updateQuestionnaireEditability();
        idStatusEl.textContent = "‚úì ID is valid (New session)";
        idStatusEl.className = "id-status id-valid";
      }
    }

    participantInput.addEventListener("input", updateIdStatus);
    participantNameInput.addEventListener("input", updateNameStatus);

    markingModeRadios.forEach(radio => {
      radio.addEventListener("change", (e) => {
        appState.setMarkingMode(e.target.value);
        
        updatePointsList();
        redrawAllFigures();
        setStatus(`Mode: ${e.target.parentElement.textContent.split('(')[0].trim()}`);
      });
    });

    function setStatus(message) {
      statusEl.childNodes[0].textContent = message;
    }

    function setSyncStatus(status) {
      syncIndicator.className = "sync-indicator";
      if (status) {
        syncIndicator.classList.add(status);
      }
    }

    function savePoint(point) {
      appState.addPoint(point);
      updatePointsList();
      const directionLabel = point.direction === "touched_by" ? "was touched" : "touched";
      setStatus(
        `Recorded: ${point.figure} (${directionLabel}). Total: ${appState.getPointsCount()}`
      );
    }

    function updatePointsList() {
      if (appState.getPointsCount() === 0) {
        pointsListEl.innerHTML = '<div class="empty-list">No points recorded yet</div>';
        return;
      }

      const filteredWithIndices = appState.collectedPoints
        .map((point, index) => ({ point, index }))
        .reverse()
        .filter(({ point }) => {
          if (appState.displayFilter === "all") return true;
          if (appState.displayFilter === "touched") return point.direction === "touched";
          if (appState.displayFilter === "touched_by") return point.direction === "touched_by";
          return true;
        });

      if (filteredWithIndices.length === 0) {
        pointsListEl.innerHTML = '<div class="empty-list">No points match current filter</div>';
        return;
      }

      pointsListEl.innerHTML = filteredWithIndices.map(({ point, index }) => {
        const directionLabel = point.direction === "touched_by" ? "I was touched" : "I touched";
        return `
        <div class="point-item">
          <div class="point-color" style="background: ${directionColors[point.direction]}"></div>
          <div class="point-info">
            <strong>${point.figure}</strong> - <strong>${directionLabel}</strong>
          </div>
          <button class="point-delete-btn" onclick="deletePoint(${index})">Delete</button>
        </div>
      `;
      }).join("");
    }

    function deletePoint(index) {
      if (appState.isExistingSession && !appState.canEdit) {
        setStatus("‚ùå Edit time limit expired. Cannot delete points.");
        return;
      }

      appState.removePoint(index);
      updatePointsList();
      setStatus(`Deleted point. Total: ${appState.getPointsCount()}`);
      
      figureConfigs.forEach(redrawFigure);
    }

    function redrawFigure(figureConfig) {
      const canvas = document.getElementById(figureConfig.canvasId);
      const ctx = canvas.getContext("2d");
      
      // Use cached image instead of reloading from network
      const img = imageCache[figureConfig.id];
      
      if (!img) {
        console.warn(`Image not cached for ${figureConfig.id}`);
        return;
      }
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      
      const filteredPoints = getFilteredPoints();
      for (const point of filteredPoints) {
        if (point.figure === figureConfig.id) {
          drawMarker(
            ctx,
            point.xNorm * canvas.width,
            point.yNorm * canvas.height,
            directionColors[point.direction]
          );
        }
      }
    }

    function setupFigure(figureConfig) {
      const canvas = document.getElementById(figureConfig.canvasId);
      const ctx = canvas.getContext("2d");
      
      // Draw initial image from cache
      const img = imageCache[figureConfig.id];
      if (img) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      }

      function recordPoint(clientX, clientY) {
        if (!appState.idIsValid || !appState.nameIsValid) {
          console.warn("Invalid ID or name:", { idIsValid: appState.idIsValid, nameIsValid: appState.nameIsValid });
          setStatus("‚ùå Invalid ID or name. Cannot record points.");
          return;
        }

        if (appState.markingMode === "view_all") {
          setStatus("‚ö†Ô∏è Viewing mode. Switch to 'Mark' mode to record points.");
          return;
        }

        if (appState.isExistingSession && !appState.canEdit) {
          setStatus("‚ùå Edit time limit expired (1 hour). Cannot add more points.");
          return;
        }

        const rect = canvas.getBoundingClientRect();
        const xPx = clientX - rect.left;
        const yPx = clientY - rect.top;

        if (xPx < 0 || xPx > rect.width || yPx < 0 || yPx > rect.height) {
          console.log("Click outside canvas bounds");
          return;
        }

        const xNorm = xPx / rect.width;
        const yNorm = yPx / rect.height;

        const direction = appState.currentDirection;
        
        console.log("Recording point:", { 
          figure: figureConfig.id, 
          direction, 
          xNorm: xNorm.toFixed(2), 
          yNorm: yNorm.toFixed(2) 
        });

        const point = {
          participantId: participantInput.value.trim(),
          participantName: participantNameInput.value.trim(),
          figure: figureConfig.id,
          direction: direction,
          xNorm: xNorm,
          yNorm: yNorm,
          timestamp: new Date().toISOString()
        };

        savePoint(point);
        redrawFigure(figureConfig);
      }

      function handleClick(event) {
        recordPoint(event.clientX, event.clientY);
      }

      let touchStartX = 0;
      let touchStartY = 0;
      let isTouchMoving = false;
      const TOUCH_MOVE_THRESHOLD = 10;

      function handleTouchStart(event) {
        if (event.touches.length > 1) {
          return;
        }
        
        const touch = event.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        isTouchMoving = false;
      }

      function handleTouchMove(event) {
        if (event.touches.length > 1) {
          return;
        }

        const touch = event.touches[0];
        const moveX = Math.abs(touch.clientX - touchStartX);
        const moveY = Math.abs(touch.clientY - touchStartY);

        if (moveX > TOUCH_MOVE_THRESHOLD || moveY > TOUCH_MOVE_THRESHOLD) {
          isTouchMoving = true;
        }
      }

      function handleTouchEnd(event) {
        if (event.touches.length > 0) {
          return;
        }

        if (!isTouchMoving) {
          const touch = event.changedTouches[0];
          recordPoint(touch.clientX, touch.clientY);
        }

        isTouchMoving = false;
      }

      canvas.addEventListener("click", handleClick);
      canvas.addEventListener("touchstart", handleTouchStart, { passive: true });
      canvas.addEventListener("touchmove", handleTouchMove, { passive: true });
      canvas.addEventListener("touchend", handleTouchEnd, { passive: true });
      
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
      }, { passive: false });
    }

    function drawMarker(ctx, x, y, color) {
      const radius = 5;
      ctx.save();
      ctx.fillStyle = color;
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function clearPoints() {
      if (confirm("Are you sure you want to delete ALL points?")) {
        appState.clearAllPoints();
        updatePointsList();
        setStatus("Cleared all points for this session.");
        figureConfigs.forEach(redrawFigure);
      }
    }

    document.getElementById("clearPoints").addEventListener("click", clearPoints);

    // Initialize
    (async () => {
      await preloadImages();
      await loadExistingIds();
      figureConfigs.forEach(setupFigure);
      setStatus("Ready. Click or tap to mark contact.");
    })();

    // Save all session data and points
    window.saveAllAndReload = async function(isRetry = false) {
      const btn = document.getElementById('saveAndSend');

      if (!appState.idIsValid || !appState.nameIsValid) {
        const validationError = new ValidationError('Participant ID and Name must be valid before saving');
        console.error(validationError.name + ":", validationError.message);
        alert('Participant ID and Name must be valid before saving.');
        return;
      }

      const hasTouched = appState.hasPointsInDirection('touched');
      const hasTouchedBy = appState.hasPointsInDirection('touched_by');
      const unanswered = appState.getUnansweredItems().map(k => k.toUpperCase());

      const missing = [];
      if (!hasTouched) missing.push('No points recorded for "I touched".');
      if (!hasTouchedBy) missing.push('No points recorded for "I was touched".');
      if (unanswered.length) missing.push(`Unanswered questionnaire items: ${unanswered.join(', ')}`);
      if (missing.length) {
        const validationError = new ValidationError(missing.join(' | '));
        console.error(validationError.name + ":", validationError.message);
        alert(missing.join('\n') + '\n\nPlease complete before saving.');
        return;
      }

      let prevText = 'Save and Send';
      try {
        if (btn) {
          btn.disabled = true;
          prevText = btn.textContent;
          btn.textContent = isRetry ? 'Retrying...' : 'Saving...';
        }

        setSyncStatus('syncing');
        setStatus(`üì§ ${isRetry ? 'Retrying' : 'Saving'} your data... (${appState.getPointsCount()} points + questionnaire)`);

        const key = dataService.getParticipantKey(participantInput.value.trim(), participantNameInput.value.trim());

        const sessionData = {
          notes: notesTextarea.value,
          confidence: appState.sessionConfidence,
          questionnaire: appState.questionnaireResponses,
          lastEdited: new Date().toISOString()
        };

        await db.ref(`data/${key}/sessionData`).set(sessionData);
        await db.ref(`data/${key}/sessionPoints`).set(appState.collectedPoints);

        setSyncStatus('synced');

        setStatus('‚úÖ All data saved successfully! Thank you for your participation.');
        if (btn) {
          btn.textContent = '‚úÖ Saved!';
        }

        setTimeout(() => {
          alert('All data are saved. Thank you for your participation.');
          setSyncStatus(null);
          location.reload();
        }, 1000);

      } catch (error) {
        const dataSaveError = new DataSaveError(`Failed to save data: ${error.message}`);
        console.error(dataSaveError.name + ":", dataSaveError.message);
        setSyncStatus('error');
        
        setStatus(`‚ùå Save failed: ${dataSaveError.message}. Click "Retry" to try again.`);
        
        if (btn) {
          btn.disabled = false;
          btn.textContent = '‚ö†Ô∏è Retry';
          btn.onclick = () => window.saveAllAndReload(true);
        }
      }
    };
  </script>

  <div style="text-align: center; margin: 2rem 0;">
    <button id="saveAndSend" type="button" class="secondary" onclick="saveAllAndReload()">Save and Send</button>
  </div>
</body>
</html>
