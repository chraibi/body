<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Physical Interaction Body Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 0;
      padding: 1rem;
      background: #f5f5f5;
    }

    h1 {
      font-size: 1.3rem;
      margin-bottom: 0.5rem;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: flex-start;
      margin-bottom: 1rem;
      padding: 1rem;
      background: white;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    label {
      font-size: 0.9rem;
      font-weight: 500;
    }

    input[type="text"],
    select {
      padding: 0.4rem 0.5rem;
      font-size: 0.9rem;
      border: 1px solid #ccc;
      border-radius: 0.3rem;
    }

    button {
      padding: 0.4rem 0.8rem;
      font-size: 0.9rem;
      cursor: pointer;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 0.3rem;
    }

    button:hover {
      background: #0056b3;
    }

    button.secondary {
      background: #6c757d;
    }

    button.secondary:hover {
      background: #545b62;
    }

    .color-legend {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      font-size: 0.85rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .legend-color {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      border: 1px solid #333;
    }

    .figures {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .figure-wrapper {
      background: white;
      padding: 0.5rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      text-align: center;
    }

    .figure-label {
      font-size: 0.9rem;
      margin-bottom: 0.25rem;
      font-weight: 500;
    }

    canvas {
      border: 1px solid #ccc;
      touch-action: none;
      cursor: crosshair;
    }

    .status {
      margin-top: 0.75rem;
      font-size: 0.85rem;
      color: #555;
    }

    .sync-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-left: 0.5rem;
      background: #ccc;
    }

    .sync-indicator.synced {
      background: #4CAF50;
    }

    .sync-indicator.syncing {
      background: #FFC107;
    }

    .sync-indicator.error {
      background: #f44336;
    }

    .id-status {
      font-size: 0.8rem;
      margin-top: 0.25rem;
      min-height: 1.2rem;
    }

    .id-valid {
      color: #4CAF50;
    }

    .id-invalid {
      color: #f44336;
    }

    /* Display Filter */
    .filter-container {
      background: white;
      padding: 1rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      margin-top: 2rem;
    }

    .filter-container h3 {
      margin-top: 0;
      margin-bottom: 1rem;
    }

    .filter-options {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .filter-options label {
      display: flex;
      align-items: flex-start;
      gap: 0.5rem;
      cursor: pointer;
      font-weight: 400;
      flex-wrap: wrap;
    }

    .filter-options input[type="radio"] {
      cursor: pointer;
      margin-top: 0.25rem;
      flex-shrink: 0;
    }

    .mode-hint {
      font-size: 0.75rem;
      color: #999;
      font-weight: normal;
      flex-basis: 100%;
      margin-left: 1.5rem;
    }

    .filter-preview {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 1px solid #333;
      margin-left: 0.5rem;
      flex-shrink: 0;
    }

    /* Points List */
    .points-list-container {
      background: white;
      padding: 1rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      margin-top: 2rem;
    }

    .points-list-container h3 {
      margin-top: 0;
      margin-bottom: 1rem;
    }

    .points-list {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #eee;
      border-radius: 0.3rem;
    }

    .point-item {
      padding: 0.75rem;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }

    .point-item:last-child {
      border-bottom: none;
    }

    .point-info {
      flex: 1;
      text-align: left;
      font-size: 0.85rem;
    }

    .point-color {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 1px solid #333;
    }

    .point-delete-btn {
      padding: 0.3rem 0.6rem;
      font-size: 0.8rem;
      background: #f44336;
      color: white;
      border: none;
      border-radius: 0.3rem;
      cursor: pointer;
    }

    .point-delete-btn:hover {
      background: #da190b;
    }

    .empty-list {
      padding: 1rem;
      text-align: center;
      color: #999;
      font-size: 0.9rem;
    }

    /* Notes Section */
    .notes-container {
      background: white;
      padding: 1rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      margin-top: 2rem;
    }

    .notes-container h3 {
      margin-top: 0;
      margin-bottom: 1rem;
    }

    .notes-content {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .notes-content label {
      font-weight: 500;
      font-size: 0.95rem;
      margin-top: 0.5rem;
    }

    #sessionNotes {
      padding: 0.75rem;
      font-size: 0.9rem;
      border: 1px solid #ccc;
      border-radius: 0.3rem;
      font-family: system-ui, sans-serif;
      resize: vertical;
      min-height: 100px;
    }

    #sessionNotes:disabled {
      background: #f5f5f5;
      cursor: not-allowed;
      color: #999;
    }

    .char-counter {
      font-size: 0.8rem;
      color: #666;
      text-align: right;
    }

    .star-rating {
      display: flex;
      gap: 0.5rem;
      font-size: 2rem;
    }

    .star {
      cursor: pointer;
      color: #ddd;
      transition: color 0.2s;
      user-select: none;
    }

    .star:hover,
    .star.active {
      color: #ffc107;
    }

    .confidence-label {
      font-size: 0.85rem;
      color: #666;
      margin-top: -0.5rem;
    }

    .save-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: #999;
      margin-top: 0.5rem;
    }

    #noteSyncIndicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ccc;
    }

    #noteSyncIndicator.synced {
      background: #4CAF50;
    }

    #noteSyncIndicator.syncing {
      background: #FFC107;
    }

    #noteSyncIndicator.error {
      background: #f44336;
    }
  </style>
</head>
<body>
  <h1>Physical Interaction Body Map</h1>

  <div class="controls">
    <div class="control-group">
      <label>Participant ID (must be a number):</label>
      <input type="text" id="participantId" placeholder="e.g. 001" />
      <div class="id-status" id="idStatus"></div>
    </div>

    <div class="control-group">
      <label>Participant Name:</label>
      <input type="text" id="participantName" placeholder="e.g. John" />
      <div class="id-status" id="nameStatus"></div>
    </div>

    <div class="control-group">
      <label>&nbsp;</label>
      <button id="clearPoints" class="secondary">Clear all points</button>
    </div>

    <!-- <div class="control-group"> -->
    <!--   <label>&nbsp;</label> -->
    <!--   <button id="downloadJson">Download JSON</button> -->
    <!-- </div> -->
  </div>

  <div class="color-legend">
    <strong>Color Legend:</strong>
    <div class="legend-item">
      <div class="legend-color" style="background: #3498db;"></div>
      <span>I touched</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #e74c3c;"></div>
      <span>I was touched</span>
    </div>
  </div>

  <div class="figures">
    <div class="figure-wrapper">
      <div class="figure-label">Front</div>
      <canvas id="figure_front" width="300" height="600"></canvas>
    </div>
    <div class="figure-wrapper">
      <div class="figure-label">Back</div>
      <canvas id="figure_back" width="300" height="600"></canvas>
    </div>
    <div class="figure-wrapper">
      <div class="figure-label">Right</div>
      <canvas id="figure_right" width="200" height="600"></canvas>
    </div>
    <div class="figure-wrapper">
      <div class="figure-label">Left</div>
      <canvas id="figure_left" width="200" height="600"></canvas>
    </div>
  </div>

  <div class="status" id="status">
    <span>Ready</span>
    <span class="sync-indicator" id="syncIndicator"></span>
  </div>

  <!-- Marking Mode -->
  <div class="filter-container">
    <h3>Marking Mode</h3>
    <div class="filter-options">
      <label>
        <input type="radio" name="markingMode" value="mark_touched_by" checked />
        Mark "I was touched" <span class="filter-preview" style="background: #e74c3c;"></span>
        <span class="mode-hint">(Records: I was touched | Shows: I touched only)</span>
      </label>
      <label>
        <input type="radio" name="markingMode" value="mark_touched" />
        Mark "I touched" <span class="filter-preview" style="background: #3498db;"></span>
        <span class="mode-hint">(Records: I touched | Shows: I was touched only)</span>
      </label>
      <label>
        <input type="radio" name="markingMode" value="view_all" />
        View All Points
        <span class="mode-hint">(Viewing only - no recording)</span>
      </label>
    </div>
  </div>

  <!-- Points List -->
  <div class="points-list-container">
    <h3>Recorded Points</h3>
    <div class="points-list" id="pointsList">
      <div class="empty-list">No points recorded yet</div>
    </div>
  </div>

  <!-- Notes Section -->
  <div class="notes-container">
    <h3>Additional Notes & Confidence</h3>
    <div class="notes-content">
      <label for="sessionNotes">Notes (500 character limit):</label>
      <textarea 
        id="sessionNotes" 
        placeholder="Any additional notes about your declarations..."
        maxlength="500"
      ></textarea>
      <div class="char-counter">
        <span id="charCount">0</span>/500
      </div>

      <label>Overall Confidence Level:</label>
      <div class="star-rating" id="starRating">
        <span class="star" data-value="1" title="Not confident">★</span>
        <span class="star" data-value="2" title="Somewhat confident">★</span>
        <span class="star" data-value="3" title="Moderately confident">★</span>
        <span class="star" data-value="4" title="Confident">★</span>
        <span class="star" data-value="5" title="Very confident">★</span>
      </div>
      <div class="confidence-label" id="confidenceLabel">(Not rated)</div>

      <div class="save-status" id="saveStatus">
        <span id="lastSaved"></span>
        <span class="sync-indicator" id="noteSyncIndicator"></span>
      </div>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/11.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.0.0/firebase-database-compat.js"></script>

  <script>
    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyDt82k5jJTa9Xqn6Xb2-oEoVTHOr-wgvuA",
      authDomain: "body-map-9cdb6.firebaseapp.com",
      databaseURL: "https://body-map-9cdb6-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "body-map-9cdb6",
      storageBucket: "body-map-9cdb6.firebasestorage.app",
      messagingSenderId: "86071836780",
      appId: "1:86071836780:web:26ba38c4bfedf7d451d849",
      measurementId: "G-GQN61BV570"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // ============ COLOR MAPPING ============
    const directionColors = {
      touched: "#3498db",        // I touched - blue
      touched_by: "#e74c3c"      // I was touched - red
    };

    // ============ APP CODE ============
    const figureConfigs = [
      { id: "front", canvasId: "figure_front", imageSrc: "front.png" },
      { id: "back",  canvasId: "figure_back",  imageSrc: "back.png"  },
      { id: "left",  canvasId: "figure_left",  imageSrc: "left.png"  },
      { id: "right", canvasId: "figure_right", imageSrc: "right.png" },
    ];

    let collectedPoints = [];
    const statusEl = document.getElementById("status");
    const syncIndicator = document.getElementById("syncIndicator");
    const participantInput = document.getElementById("participantId");
    const idStatusEl = document.getElementById("idStatus");
    const participantNameInput = document.getElementById("participantName");
    const nameStatusEl = document.getElementById("nameStatus");
    const pointsListEl = document.getElementById("pointsList");

    let idIsValid = false;
    let nameIsValid = false;
    let existingKeys = new Set();
    let isExistingSession = false;
    let firstEntryTimestamp = null;
    let canEdit = true;
    const EDIT_TIME_LIMIT = 60 * 60 * 1000; // 1 hour in milliseconds
    
    // Session notes
    let sessionNotes = "";
    let sessionConfidence = 0;
    let autoSaveTimer = null;
    const AUTO_SAVE_DELAY = 1500; // Save 1.5 seconds after user stops typing

    // Marking mode (unified control for direction + display)
    let markingMode = "mark_touched_by"; // "mark_touched_by", "mark_touched", or "view_all"
    let currentDirection = "touched_by"; // Current recording direction
    let displayFilter = "touched"; // Current display filter

    // DOM elements for notes
    const notesTextarea = document.getElementById("sessionNotes");
    const starRating = document.getElementById("starRating");
    const confidenceLabel = document.getElementById("confidenceLabel");
    const charCountEl = document.getElementById("charCount");
    const lastSavedEl = document.getElementById("lastSaved");
    const noteSyncIndicator = document.getElementById("noteSyncIndicator");

    // DOM elements for marking mode
    const markingModeRadios = document.querySelectorAll('input[name="markingMode"]');

    // Load existing IDs from Firebase on startup
    async function loadExistingIds() {
      try {
        const snapshot = await db.ref("data").once("value");
        if (snapshot.exists()) {
          existingKeys = new Set(Object.keys(snapshot.val()));
        }
      } catch (error) {
        console.error("Error loading existing keys:", error);
      }
    }

    function getParticipantKey(id, name) {
      return `${id}_${name.toLowerCase()}`;
    }

    function isValidNumericId(id) {
      return id && /^\d+$/.test(id);
    }

    function isValidName(name) {
      return name && name.trim().length > 0;
    }

    function keyAlreadyExists(id, name) {
      const key = getParticipantKey(id, name);
      return existingKeys.has(key);
    }

    async function loadExistingParticipantData(id, name) {
      try {
        const key = getParticipantKey(id, name);
        const snapshot = await db.ref(`data/${key}`).once("value");
        
        if (snapshot.exists()) {
          const data = snapshot.val();
          const points = [];
          let earliestTimestamp = null;

          // Convert Firebase data to points array
          for (const timestamp in data) {
            const point = data[timestamp];
            points.push(point);
            
            // Track the earliest (first) entry
            const pointTime = new Date(point.timestamp).getTime();
            if (earliestTimestamp === null || pointTime < earliestTimestamp) {
              earliestTimestamp = pointTime;
            }
          }

          // Sort points by timestamp (newest first)
          points.sort((a, b) => {
            const timeA = new Date(a.timestamp).getTime();
            const timeB = new Date(b.timestamp).getTime();
            return timeB - timeA; // Descending order (newest first)
          });

          // Set session state
          isExistingSession = true;
          firstEntryTimestamp = earliestTimestamp;
          collectedPoints = points;
          
          // Check if still within edit window
          const now = Date.now();
          const elapsed = now - firstEntryTimestamp;
          canEdit = elapsed < EDIT_TIME_LIMIT;
          
          updatePointsList();
          redrawAllFigures();
          
          // Load session notes and confidence
          if (data.sessionData) {
            sessionNotes = data.sessionData.notes || "";
            sessionConfidence = data.sessionData.confidence || 0;
            updateNotesDisplay();
          } else {
            resetNotes();
          }
          
          updateEditStatus();
          startEditStatusTimer();
          updateNotesEditability();
          
          return true;
        }
      } catch (error) {
        console.error("Error loading participant data:", error);
      }
      
      return false;
    }

    function updateEditStatus() {
      if (!isExistingSession) {
        idStatusEl.textContent = "✓ ID is valid";
        idStatusEl.className = "id-status id-valid";
        return;
      }

      if (canEdit) {
        const elapsed = Date.now() - firstEntryTimestamp;
        const remaining = EDIT_TIME_LIMIT - elapsed;
        
        // Check if time limit just expired
        if (remaining <= 0) {
          canEdit = false;
          idStatusEl.textContent = "❌ Edit time limit expired (1 hour)";
          idStatusEl.className = "id-status id-invalid";
          return;
        }
        
        const minutesRemaining = Math.ceil(remaining / 60000);
        idStatusEl.textContent = `✓ Editing enabled (${minutesRemaining} min remaining)`;
        idStatusEl.className = "id-status id-valid";
      } else {
        idStatusEl.textContent = "❌ Edit time limit expired (1 hour)";
        idStatusEl.className = "id-status id-invalid";
      }
    }

    let editStatusTimer = null;
    
    function startEditStatusTimer() {
      // Update every 30 seconds to show countdown
      if (editStatusTimer) clearInterval(editStatusTimer);
      editStatusTimer = setInterval(() => {
        if (isExistingSession) {
          updateEditStatus();
        }
      }, 30000); // Update every 30 seconds
    }

    function stopEditStatusTimer() {
      if (editStatusTimer) {
        clearInterval(editStatusTimer);
        editStatusTimer = null;
      }
    }

    function resetNotes() {
      sessionNotes = "";
      sessionConfidence = 0;
      notesTextarea.value = "";
      charCountEl.textContent = "0";
      confidenceLabel.textContent = "(Not rated)";
      document.querySelectorAll(".star").forEach(star => star.classList.remove("active"));
      lastSavedEl.textContent = "";
    }

    function updateNotesDisplay() {
      notesTextarea.value = sessionNotes;
      charCountEl.textContent = sessionNotes.length;
      updateStarsDisplay();
      updateNotesEditability();
    }

    function updateStarsDisplay() {
      document.querySelectorAll(".star").forEach(star => {
        const value = parseInt(star.dataset.value);
        if (value <= sessionConfidence) {
          star.classList.add("active");
        } else {
          star.classList.remove("active");
        }
      });

      const labels = {
        0: "(Not rated)",
        1: "Not confident",
        2: "Somewhat confident",
        3: "Moderately confident",
        4: "Confident",
        5: "Very confident"
      };
      confidenceLabel.textContent = labels[sessionConfidence] || "(Not rated)";
    }

    function updateNotesEditability() {
      const disabled = isExistingSession && !canEdit;
      notesTextarea.disabled = disabled;
      document.querySelectorAll(".star").forEach(star => {
        if (disabled) {
          star.style.pointerEvents = "none";
          star.style.opacity = "0.5";
        } else {
          star.style.pointerEvents = "auto";
          star.style.opacity = "1";
        }
      });
    }

    function updateCharCounter() {
      charCountEl.textContent = notesTextarea.value.length;
    }

    function autoSaveSessionData() {
      if (autoSaveTimer) clearTimeout(autoSaveTimer);
      
      autoSaveTimer = setTimeout(() => {
        saveSessionData();
      }, AUTO_SAVE_DELAY);
    }

    async function saveSessionData() {
      if (!isExistingSession || !canEdit) return;
      
      try {
        const key = getParticipantKey(participantInput.value.trim(), participantNameInput.value.trim());
        const sessionData = {
          notes: notesTextarea.value,
          confidence: sessionConfidence,
          lastEdited: new Date().toISOString()
        };

        noteSyncIndicator.className = "sync-indicator syncing";
        
        await db.ref(`data/${key}/sessionData`).set(sessionData);
        
        sessionNotes = notesTextarea.value;
        noteSyncIndicator.className = "sync-indicator synced";
        lastSavedEl.textContent = `Last saved: ${new Date().toLocaleTimeString()}`;
        
        setTimeout(() => {
          noteSyncIndicator.className = "sync-indicator";
        }, 2000);
      } catch (error) {
        console.error("Error saving session data:", error);
        noteSyncIndicator.className = "sync-indicator error";
      }
    }

    // Notes event listeners
    notesTextarea.addEventListener("input", (e) => {
      updateCharCounter();
      autoSaveSessionData();
    });

    document.querySelectorAll(".star").forEach(star => {
      star.addEventListener("click", (e) => {
        if (isExistingSession && !canEdit) return;
        
        sessionConfidence = parseInt(e.target.dataset.value);
        updateStarsDisplay();
        autoSaveSessionData();
      });

      star.addEventListener("mouseover", (e) => {
        const value = parseInt(e.target.dataset.value);
        document.querySelectorAll(".star").forEach(s => {
          if (parseInt(s.dataset.value) <= value) {
            s.style.color = "#ffc107";
          } else {
            s.style.color = "#ddd";
          }
        });
      });
    });

    starRating.addEventListener("mouseleave", () => {
      updateStarsDisplay();
    });

    function getFilteredPoints() {
      if (displayFilter === "all") {
        return collectedPoints;
      } else if (displayFilter === "touched") {
        return collectedPoints.filter(point => point.direction === "touched");
      } else if (displayFilter === "touched_by") {
        return collectedPoints.filter(point => point.direction === "touched_by");
      }
      return collectedPoints;
    }

    function redrawAllFigures() {
      figureConfigs.forEach(redrawFigure);
    }

    async function updateIdStatus() {
      const id = participantInput.value.trim();

      if (!id) {
        idIsValid = false;
        idStatusEl.textContent = "";
        idStatusEl.className = "id-status";
        return;
      }

      if (!isValidNumericId(id)) {
        idIsValid = false;
        idStatusEl.textContent = "❌ ID must be a number (digits only)";
        idStatusEl.className = "id-status id-invalid";
        return;
      }

      idIsValid = true;
      idStatusEl.textContent = "✓ ID is valid";
      idStatusEl.className = "id-status id-valid";
      
      // Check combined key validity if name is also present
      updateCombinedKeyStatus();
    }

    async function updateNameStatus() {
      const name = participantNameInput.value.trim();

      if (!name) {
        nameIsValid = false;
        nameStatusEl.textContent = "";
        nameStatusEl.className = "id-status";
        return;
      }

      nameIsValid = true;
      nameStatusEl.textContent = "✓ Name is valid";
      nameStatusEl.className = "id-status id-valid";
      
      // Check combined key validity if ID is also present
      updateCombinedKeyStatus();
    }

    async function updateCombinedKeyStatus() {
      const id = participantInput.value.trim();
      const name = participantNameInput.value.trim();
      
      if (!idIsValid || !nameIsValid) {
        return;
      }

      // Try to load existing participant data
      const dataExists = await loadExistingParticipantData(id, name);
      
      if (!dataExists) {
        // New session - reset state
        stopEditStatusTimer();
        isExistingSession = false;
        firstEntryTimestamp = null;
        canEdit = true;
        collectedPoints = [];
        updatePointsList();
        redrawAllFigures();
        resetNotes();
        updateNotesEditability();
        idStatusEl.textContent = "✓ ID is valid (New session)";
        idStatusEl.className = "id-status id-valid";
      }
    }

    participantInput.addEventListener("input", updateIdStatus);
    participantNameInput.addEventListener("input", updateNameStatus);

    // Marking mode event listeners
    markingModeRadios.forEach(radio => {
      radio.addEventListener("change", (e) => {
        markingMode = e.target.value;
        
        // Update recording direction and display filter based on marking mode
        if (markingMode === "mark_touched_by") {
          currentDirection = "touched_by";
          displayFilter = "touched"; // Show only "I touched" for reference
        } else if (markingMode === "mark_touched") {
          currentDirection = "touched";
          displayFilter = "touched_by"; // Show only "I was touched" for reference
        } else if (markingMode === "view_all") {
          displayFilter = "all"; // Show all points
        }
        
        updatePointsList();
        redrawAllFigures();
        setStatus(`Mode: ${e.target.parentElement.textContent.split('(')[0].trim()}`);
      });
    });

    function setStatus(message) {
      statusEl.childNodes[0].textContent = message;
    }

    function setSyncStatus(status) {
      syncIndicator.className = "sync-indicator";
      if (status) {
        syncIndicator.classList.add(status);
      }
    }

    // Show confidence modal
    async function sendToFirebase(point) {
      try {
        setSyncStatus("syncing");
        const participantKey = getParticipantKey(point.participantId, point.participantName);
        const timestamp = Date.now();
        
        await db.ref(`data/${participantKey}/${timestamp}`).set(point);
        
        setSyncStatus("synced");
        setTimeout(() => setSyncStatus(null), 2000);
      } catch (error) {
        console.error("Firebase error:", error);
        setSyncStatus("error");
        setStatus(`Error syncing to server. Data saved locally.`);
      }
    }

    function savePoint(point) {
      // Insert new point at the beginning (unshift) to keep newest first
      collectedPoints.unshift(point);
      sendToFirebase(point);
      updatePointsList();
      const directionLabel = point.direction === "touched_by" ? "was touched" : "touched";
      setStatus(
        `Recorded: ${point.figure} (${directionLabel}). Total: ${collectedPoints.length}`
      );
    }

    function updatePointsList() {
      if (collectedPoints.length === 0) {
        pointsListEl.innerHTML = '<div class="empty-list">No points recorded yet</div>';
        return;
      }

      // Create filtered list with original indices
      const filteredWithIndices = collectedPoints
        .map((point, index) => ({ point, index }))
        .reverse() // Reverse to show newest first
        .filter(({ point }) => {
          if (displayFilter === "all") return true;
          if (displayFilter === "touched") return point.direction === "touched";
          if (displayFilter === "touched_by") return point.direction === "touched_by";
          return true;
        });

      if (filteredWithIndices.length === 0) {
        pointsListEl.innerHTML = '<div class="empty-list">No points match current filter</div>';
        return;
      }

      pointsListEl.innerHTML = filteredWithIndices.map(({ point, index }) => {
        const directionLabel = point.direction === "touched_by" ? "I was touched" : "I touched";
        return `
        <div class="point-item">
          <div class="point-color" style="background: ${directionColors[point.direction]}"></div>
          <div class="point-info">
            <strong>${point.figure}</strong> - <strong>${directionLabel}</strong>
          </div>
          <button class="point-delete-btn" onclick="deletePoint(${index})">Delete</button>
        </div>
      `;
      }).join("");
    }

    function deletePoint(index) {
      if (isExistingSession && !canEdit) {
        setStatus("❌ Edit time limit expired. Cannot delete points.");
        return;
      }

      collectedPoints.splice(index, 1);
      updatePointsList();
      setStatus(`Deleted point. Total: ${collectedPoints.length}`);
      
      // Redraw all figures to remove the deleted marker
      figureConfigs.forEach(redrawFigure);
    }

    function redrawFigure(figureConfig) {
      const canvas = document.getElementById(figureConfig.canvasId);
      const ctx = canvas.getContext("2d");
      const img = new Image();
      img.src = figureConfig.imageSrc;

      img.onload = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        
        // Redraw filtered markers for this figure
        const filteredPoints = getFilteredPoints();
        for (const point of filteredPoints) {
          if (point.figure === figureConfig.id) {
            drawMarker(
              ctx,
              point.xNorm * canvas.width,
              point.yNorm * canvas.height,
              directionColors[point.direction]
            );
          }
        }
      };
    }

    function setupFigure(figureConfig) {
      const canvas = document.getElementById(figureConfig.canvasId);
      const ctx = canvas.getContext("2d");
      const img = new Image();
      img.src = figureConfig.imageSrc;

      img.onload = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      };

      function recordPoint(clientX, clientY) {
        if (!idIsValid || !nameIsValid) {
          setStatus("❌ Invalid ID or name. Cannot record points.");
          return;
        }

        if (markingMode === "view_all") {
          setStatus("⚠️ Viewing mode. Switch to 'Mark' mode to record points.");
          return;
        }

        if (isExistingSession && !canEdit) {
          setStatus("❌ Edit time limit expired (1 hour). Cannot add more points.");
          return;
        }

        const rect = canvas.getBoundingClientRect();
        const xPx = clientX - rect.left;
        const yPx = clientY - rect.top;

        if (xPx < 0 || xPx > rect.width || yPx < 0 || yPx > rect.height) {
          return;
        }

        const xNorm = xPx / rect.width;
        const yNorm = yPx / rect.height;

        // Use current marking mode direction
        const direction = currentDirection;

        // Create point and save immediately
        const point = {
          participantId: participantInput.value.trim(),
          participantName: participantNameInput.value.trim(),
          figure: figureConfig.id,
          direction: direction,
          xNorm: xNorm,
          yNorm: yNorm,
          timestamp: new Date().toISOString()
        };

        savePoint(point);
        redrawFigure(figureConfig);
      }

      function handleClick(event) {
        recordPoint(event.clientX, event.clientY);
      }

      function handleTouch(event) {
        event.preventDefault();
        const touch = event.changedTouches[0];
        recordPoint(touch.clientX, touch.clientY);
      }

      canvas.addEventListener("click", handleClick);
      canvas.addEventListener("touchstart", handleTouch, { passive: false });
    }

    function drawMarker(ctx, x, y, color) {
      const radius = 5;
      ctx.save();
      ctx.fillStyle = color;
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function downloadFile(filename, mimeType, content) {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function downloadAsJson() {
      if (collectedPoints.length === 0) {
        alert("No points recorded yet.");
        return;
      }
      const participantId = participantInput.value.trim() || "unknown";
      const filename = `body_map_${participantId}_${Date.now()}.json`;
      downloadFile(filename, "application/json", JSON.stringify(collectedPoints, null, 2));
    }

    function clearPoints() {
      if (confirm("Are you sure you want to delete ALL points?")) {
        collectedPoints.length = 0;
        updatePointsList();
        setStatus("Cleared all points for this session.");
        figureConfigs.forEach(redrawFigure);
      }
    }

    // document.getElementById("downloadJson").addEventListener("click", downloadAsJson);
    document.getElementById("clearPoints").addEventListener("click", clearPoints);

    // Initialize
    loadExistingIds();
    figureConfigs.forEach(setupFigure);
    setStatus("Ready. Click or tap to mark contact.");
  </script>
</body>
</html>
