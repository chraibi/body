<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Physical Interaction Body Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 0;
      padding: 1rem;
      background: #f5f5f5;
    }

    h1 {
      font-size: 1.3rem;
      margin-bottom: 0.5rem;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: flex-start;
      margin-bottom: 1rem;
      padding: 1rem;
      background: white;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    label {
      font-size: 0.9rem;
      font-weight: 500;
    }

    input[type="text"],
    select {
      padding: 0.4rem 0.5rem;
      font-size: 0.9rem;
      border: 1px solid #ccc;
      border-radius: 0.3rem;
    }

    button {
      padding: 0.4rem 0.8rem;
      font-size: 0.9rem;
      cursor: pointer;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 0.3rem;
    }

    button:hover {
      background: #0056b3;
    }

    button.secondary {
      background: #6c757d;
    }

    button.secondary:hover {
      background: #545b62;
    }


    .figures {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .figure-wrapper {
      background: white;
      padding: 0.5rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      text-align: center;
    }

    .figure-label {
      font-size: 0.9rem;
      margin-bottom: 0.25rem;
      font-weight: 500;
    }

    canvas {
      border: 1px solid #ccc;
      touch-action: auto;
      cursor: crosshair;
    }

    .status {
      margin-top: 0.75rem;
      font-size: 0.85rem;
      color: #555;
    }

    .sync-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-left: 0.5rem;
      background: #ccc;
    }

    .sync-indicator.synced {
      background: #4CAF50;
    }

    .sync-indicator.syncing {
      background: #FFC107;
    }

    .sync-indicator.error {
      background: #f44336;
    }

    .id-status {
      font-size: 0.8rem;
      margin-top: 0.25rem;
      min-height: 1.2rem;
    }

    .id-valid {
      color: #4CAF50;
    }

    .id-invalid {
      color: #f44336;
    }

    /* Display Filter */
    .filter-container {
      position: sticky;
      top: 0;
      z-index: 100;
      background: white;
      padding: 1rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      margin-top: 2rem;
    }

    .filter-container h3 {
      margin-top: 0;
      margin-bottom: 1rem;
    }

    .filter-options {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .filter-options label {
      display: flex;
      align-items: flex-start;
      gap: 0.5rem;
      cursor: pointer;
      font-weight: 400;
      flex-wrap: wrap;
    }

    .filter-options input[type="radio"] {
      cursor: pointer;
      margin-top: 0.25rem;
      flex-shrink: 0;
    }

    .mode-hint {
      font-size: 0.75rem;
      color: #999;
      font-weight: normal;
      flex-basis: 100%;
      margin-left: 1.5rem;
    }

    .filter-preview {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 1px solid #333;
      margin-left: 0.5rem;
      flex-shrink: 0;
    }

    /* Points List */
    .points-list-container {
      background: white;
      padding: 1rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      margin-top: 2rem;
    }

    .points-list-container h3 {
      margin-top: 0;
      margin-bottom: 1rem;
    }

    .points-list {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #eee;
      border-radius: 0.3rem;
    }

    .point-item {
      padding: 0.75rem;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }

    .point-item:last-child {
      border-bottom: none;
    }

    .point-info {
      flex: 1;
      text-align: left;
      font-size: 0.85rem;
    }

    .point-color {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 1px solid #333;
    }

    .point-delete-btn {
      padding: 0.3rem 0.6rem;
      font-size: 0.8rem;
      background: #f44336;
      color: white;
      border: none;
      border-radius: 0.3rem;
      cursor: pointer;
    }

    .point-delete-btn:hover {
      background: #da190b;
    }

    .empty-list {
      padding: 1rem;
      text-align: center;
      color: #999;
      font-size: 0.9rem;
    }

    /* Confidence Level Section */
    .confidence-container {
      background: white;
      padding: 1rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      margin-top: 2rem;
    }

    .confidence-container h3 {
      margin-top: 0;
      margin-bottom: 1rem;
    }

    .confidence-content {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    /* Notes Section */
    .notes-container {
      background: white;
      padding: 1rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      margin-top: 2rem;
    }

    .notes-container h3 {
      margin-top: 0;
      margin-bottom: 1rem;
    }

    .notes-content {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .notes-content label {
      font-weight: 500;
      font-size: 0.95rem;
      margin-top: 0.5rem;
    }

    #sessionNotes {
      padding: 0.75rem;
      font-size: 0.9rem;
      border: 1px solid #ccc;
      border-radius: 0.3rem;
      font-family: system-ui, sans-serif;
      resize: vertical;
      min-height: 100px;
    }

    #sessionNotes:disabled {
      background: #f5f5f5;
      cursor: not-allowed;
      color: #999;
    }

    .char-counter {
      font-size: 0.8rem;
      color: #666;
      text-align: right;
    }

    .star-rating {
      display: flex;
      gap: 0.5rem;
      font-size: 2rem;
    }

    .star {
      cursor: pointer;
      color: #ddd;
      transition: color 0.2s;
      user-select: none;
    }

    .star:hover,
    .star.active {
      color: #ffc107;
    }

    .confidence-label {
      font-size: 0.85rem;
      color: #666;
      margin-top: -0.5rem;
    }

    .save-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: #999;
      margin-top: 0.5rem;
    }

    #noteSyncIndicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ccc;
    }

    #noteSyncIndicator.synced {
      background: #4CAF50;
    }

    #noteSyncIndicator.syncing {
      background: #FFC107;
    }

    #noteSyncIndicator.error {
      background: #f44336;
    }

    /* Questionnaire Section */
    .questionnaire-container {
      background: white;
      padding: 1rem;
      border-radius: 0.4rem;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      margin-top: 2rem;
    }

    .questionnaire-container h3 {
      margin-top: 0;
      margin-bottom: 1.5rem;
    }

    .questionnaire-content {
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    .questionnaire-question {
      padding: 1rem;
      border: 1px solid #eee;
      border-radius: 0.3rem;
      background: #fafafa;
    }

    .question-text {
      display: block;
      font-weight: 500;
      margin-bottom: 0.5rem;
      font-size: 0.95rem;
      line-height: 1.4;
      color: #333;
    }

    .scale-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #666;
      margin-bottom: 0.75rem;
      padding: 0 0.5rem;
    }

    .rating-scale {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-start;
    }

    .rating-scale input[type="radio"] {
      display: none;
    }

    .rating-scale label {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 35px;
      height: 35px;
      border: 2px solid #ddd;
      border-radius: 0.3rem;
      cursor: pointer;
      font-weight: 500;
      font-size: 0.9rem;
      transition: all 0.2s;
      background: white;
    }

    .rating-scale label:hover {
      border-color: #3498db;
      background: #f0f8ff;
    }

    .rating-scale input[type="radio"]:checked + label {
      background: #3498db;
      color: white;
      border-color: #3498db;
    }

    .questionnaire-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: #999;
      margin-top: 1rem;
    }

    #questionnaireSyncIndicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ccc;
    }

    #questionnaireSyncIndicator.synced {
      background: #4CAF50;
    }

    #questionnaireSyncIndicator.syncing {
      background: #FFC107;
    }

    #questionnaireSyncIndicator.error {
      background: #f44336;
    }
  </style>
</head>
<body>
  <h1>Physical Interaction Body Map</h1>

  <div class="controls">
    <div class="control-group">
      <label>Participant ID (must be a number):</label>
      <input type="text" id="participantId" placeholder="e.g. 001" />
      <div class="id-status" id="idStatus"></div>
    </div>

    <div class="control-group">
      <label>Participant Name:</label>
      <input type="text" id="participantName" placeholder="e.g. John" />
      <div class="id-status" id="nameStatus"></div>
    </div>

    <div class="control-group">
      <label>&nbsp;</label>
      <button id="clearPoints" class="secondary">Clear all points</button>
    </div>

    <!-- <div class="control-group"> -->
    <!--   <label>&nbsp;</label> -->
    <!--   <button id="downloadJson">Download JSON</button> -->
    <!-- </div> -->
  </div>

  <!-- Marking Mode -->
  <div class="filter-container">
    <div class="filter-options">
      <label>
        <input type="radio" name="markingMode" value="mark_touched_by" checked />
        Mark "I was touched" <span class="filter-preview" style="background: #e74c3c;"></span>
        <span class="mode-hint">(Records & Shows: I was touched)</span>
      </label>
      <label>
        <input type="radio" name="markingMode" value="mark_touched" />
        Mark "I touched" <span class="filter-preview" style="background: #3498db;"></span>
        <span class="mode-hint">(Records & Shows: I touched)</span>
      </label>
      <label>
        <input type="radio" name="markingMode" value="view_all" />
        View All Points
        <span class="mode-hint">(Viewing only - no recording)</span>
      </label>
    </div>
  </div>

  <div class="figures">
    <div class="figure-wrapper">
      <div class="figure-label">Front</div>
      <canvas id="figure_front" width="200" height="600"></canvas>
    </div>
    <div class="figure-wrapper">
      <div class="figure-label">Right</div>
      <canvas id="figure_right" width="100" height="600"></canvas>
    </div>
    <div class="figure-wrapper">
      <div class="figure-label">Back</div>
      <canvas id="figure_back" width="200" height="600"></canvas>
    </div>
    <div class="figure-wrapper">
      <div class="figure-label">Left</div>
      <canvas id="figure_left" width="100" height="600"></canvas>
    </div>
  </div>

  <div class="status" id="status">
    <span>Ready</span>
    <span class="sync-indicator" id="syncIndicator"></span>
  </div>

  <!-- Points List -->
  <div class="points-list-container">
    <h3>Recorded Points</h3>
    <div class="points-list" id="pointsList">
      <div class="empty-list">No points recorded yet</div>
    </div>
  </div>

  <!-- Questionnaire Section -->
  <div class="questionnaire-container">
    <h3>Questionnaire</h3>
    <div class="questionnaire-content">
      
      <!-- Question 1 -->
      <div class="questionnaire-question">
        <label class="question-text">
          How would you rate your confidence in the patterns you drew to represent the physical interaction you <strong>gave</strong>?
        </label>
        <div class="scale-labels">
          <span>0 = Not confident at all</span>
          <span>5 = Extremely confident</span>
        </div>
        <div class="rating-scale" id="q1Scale">
          <input type="radio" name="q1" value="0" id="q1_0"><label for="q1_0">0</label>
          <input type="radio" name="q1" value="1" id="q1_1"><label for="q1_1">1</label>
          <input type="radio" name="q1" value="2" id="q1_2"><label for="q1_2">2</label>
          <input type="radio" name="q1" value="3" id="q1_3"><label for="q1_3">3</label>
          <input type="radio" name="q1" value="4" id="q1_4"><label for="q1_4">4</label>
          <input type="radio" name="q1" value="5" id="q1_5"><label for="q1_5">5</label>
        </div>
      </div>

      <!-- Question 2 -->
      <div class="questionnaire-question">
        <label class="question-text">
          How would you rate your confidence in the patterns you drew to represent the physical interaction you <strong>received</strong>?
        </label>
        <div class="scale-labels">
          <span>0 = Not confident at all</span>
          <span>5 = Extremely confident</span>
        </div>
        <div class="rating-scale" id="q2Scale">
          <input type="radio" name="q2" value="0" id="q2_0"><label for="q2_0">0</label>
          <input type="radio" name="q2" value="1" id="q2_1"><label for="q2_1">1</label>
          <input type="radio" name="q2" value="2" id="q2_2"><label for="q2_2">2</label>
          <input type="radio" name="q2" value="3" id="q2_3"><label for="q2_3">3</label>
          <input type="radio" name="q2" value="4" id="q2_4"><label for="q2_4">4</label>
          <input type="radio" name="q2" value="5" id="q2_5"><label for="q2_5">5</label>
        </div>
      </div>

      <!-- Question 3 -->
      <div class="questionnaire-question">
        <label class="question-text">
          How would you rate your general awareness of contacts in crowded environments?
        </label>
        <div class="scale-labels">
          <span>0 = Never aware of physical interactions</span>
          <span>5 = Extremely aware</span>
        </div>
        <div class="rating-scale" id="q3Scale">
          <input type="radio" name="q3" value="0" id="q3_0"><label for="q3_0">0</label>
          <input type="radio" name="q3" value="1" id="q3_1"><label for="q3_1">1</label>
          <input type="radio" name="q3" value="2" id="q3_2"><label for="q3_2">2</label>
          <input type="radio" name="q3" value="3" id="q3_3"><label for="q3_3">3</label>
          <input type="radio" name="q3" value="4" id="q3_4"><label for="q3_4">4</label>
          <input type="radio" name="q3" value="5" id="q3_5"><label for="q3_5">5</label>
        </div>
      </div>

      <!-- Question 4 -->
      <div class="questionnaire-question">
        <label class="question-text">
          How would you rate your awareness of contacts during the experiments?
        </label>
        <div class="scale-labels">
          <span>0 = Never aware of physical interactions</span>
          <span>5 = Extremely aware</span>
        </div>
        <div class="rating-scale" id="q4Scale">
          <input type="radio" name="q4" value="0" id="q4_0"><label for="q4_0">0</label>
          <input type="radio" name="q4" value="1" id="q4_1"><label for="q4_1">1</label>
          <input type="radio" name="q4" value="2" id="q4_2"><label for="q4_2">2</label>
          <input type="radio" name="q4" value="3" id="q4_3"><label for="q4_3">3</label>
          <input type="radio" name="q4" value="4" id="q4_4"><label for="q4_4">4</label>
          <input type="radio" name="q4" value="5" id="q4_5"><label for="q4_5">5</label>
        </div>
      </div>

      <div class="questionnaire-status" id="questionnaireStatus">
        <span id="qLastSaved"></span>
        <span class="sync-indicator" id="questionnaireSyncIndicator"></span>
      </div>
    </div>
  </div>

  <!-- Overall Confidence Level Section -->
  <div class="confidence-container">
    <h3>Overall Confidence Level</h3>
    <div class="confidence-content">
      <div class="star-rating" id="starRating">
        <span class="star" data-value="1" title="Not confident">★</span>
        <span class="star" data-value="2" title="Somewhat confident">★</span>
        <span class="star" data-value="3" title="Moderately confident">★</span>
        <span class="star" data-value="4" title="Confident">★</span>
        <span class="star" data-value="5" title="Very confident">★</span>
      </div>
      <div class="confidence-label" id="confidenceLabel">(Not rated)</div>

      <div class="save-status" id="saveStatus">
        <span id="lastSaved"></span>
        <span class="sync-indicator" id="noteSyncIndicator"></span>
      </div>
    </div>
  </div>

  <!-- Additional Comments Section -->
  <div class="notes-container">
    <h3>Additional Comments</h3>
    <div class="notes-content">
      <label for="sessionNotes">Comments (500 character limit):</label>
      <textarea 
        id="sessionNotes" 
        placeholder="Any additional comments about your declarations..."
        maxlength="500"
      ></textarea>
      <div class="char-counter">
        <span id="charCount">0</span>/500
      </div>

      <div class="save-status" id="saveStatus">
        <span id="lastSaved"></span>
        <span class="sync-indicator" id="noteSyncIndicator"></span>
      </div>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/11.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.0.0/firebase-database-compat.js"></script>

  <script>
    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyDt82k5jJTa9Xqn6Xb2-oEoVTHOr-wgvuA",
      authDomain: "body-map-9cdb6.firebaseapp.com",
      databaseURL: "https://body-map-9cdb6-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "body-map-9cdb6",
      storageBucket: "body-map-9cdb6.firebasestorage.app",
      messagingSenderId: "86071836780",
      appId: "1:86071836780:web:26ba38c4bfedf7d451d849",
      measurementId: "G-GQN61BV570"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // ============ COLOR MAPPING ============
    const directionColors = {
      touched: "#3498db",        // I touched - blue
      touched_by: "#e74c3c"      // I was touched - red
    };

    // ============ APP CODE ============
    const figureConfigs = [
      { id: "front", canvasId: "figure_front", imageSrc: "front.svg" },
      { id: "back",  canvasId: "figure_back",  imageSrc: "back.svg"  },
      { id: "left",  canvasId: "figure_left",  imageSrc: "left.svg"  },
      { id: "right", canvasId: "figure_right", imageSrc: "right.svg" },
    ];

    let collectedPoints = [];
    const statusEl = document.getElementById("status");
    const syncIndicator = document.getElementById("syncIndicator");
    const participantInput = document.getElementById("participantId");
    const idStatusEl = document.getElementById("idStatus");
    const participantNameInput = document.getElementById("participantName");
    const nameStatusEl = document.getElementById("nameStatus");
    const pointsListEl = document.getElementById("pointsList");

    let idIsValid = false;
    let nameIsValid = false;
    let existingKeys = new Set();
    let isExistingSession = false;
    let firstEntryTimestamp = null;
    let canEdit = true;
    const EDIT_TIME_LIMIT = 60 * 60 * 1000; // 1 hour in milliseconds
    
    // Session notes
    let sessionNotes = "";
    let sessionConfidence = 0;

    // Questionnaire responses
    let questionnaireResponses = {
      q1: null,
      q2: null,
      q3: null,
      q4: null
    };

    // Marking mode (unified control for direction + display)
    let markingMode = "mark_touched_by"; // "mark_touched_by", "mark_touched", or "view_all"
    let currentDirection = "touched_by"; // Current recording direction
    let displayFilter = "touched_by"; // Current display filter - show what you're recording

    // DOM elements for notes
    const notesTextarea = document.getElementById("sessionNotes");
    const starRating = document.getElementById("starRating");
    const confidenceLabel = document.getElementById("confidenceLabel");
    const charCountEl = document.getElementById("charCount");
    const lastSavedEl = document.getElementById("lastSaved");
    const noteSyncIndicator = document.getElementById("noteSyncIndicator");

    // Questionnaire elements
    const questionnaireRadios = {
      q1: document.querySelectorAll('input[name="q1"]'),
      q2: document.querySelectorAll('input[name="q2"]'),
      q3: document.querySelectorAll('input[name="q3"]'),
      q4: document.querySelectorAll('input[name="q4"]')
    };
    const qLastSavedEl = document.getElementById("qLastSaved");
    const questionnaireSyncIndicator = document.getElementById("questionnaireSyncIndicator");

    // DOM elements for marking mode
    const markingModeRadios = document.querySelectorAll('input[name="markingMode"]');

    // Load existing IDs from Firebase on startup
    async function loadExistingIds() {
      try {
        const snapshot = await db.ref("data").once("value");
        if (snapshot.exists()) {
          existingKeys = new Set(Object.keys(snapshot.val()));
          console.log("Loaded existing keys:", existingKeys);
        } else {
          console.log("Database is empty - ready for new sessions");
          existingKeys = new Set();
        }
      } catch (error) {
        console.error("Error loading existing keys:", error);
        // Even if loading fails, allow app to continue - user can still add new data
        existingKeys = new Set();
      }
    }

    function getParticipantKey(id, name) {
      return `${id}_${name.toLowerCase()}`;
    }

    function isValidNumericId(id) {
      return id && /^\d+$/.test(id);
    }

    function isValidName(name) {
      return name && name.trim().length > 0;
    }

    function keyAlreadyExists(id, name) {
      const key = getParticipantKey(id, name);
      return existingKeys.has(key);
    }

    async function loadExistingParticipantData(id, name) {
      try {
        const key = getParticipantKey(id, name);
        const snapshot = await db.ref(`data/${key}`).once("value");
        
        if (snapshot.exists()) {
          const data = snapshot.val();
          const points = [];
          let earliestTimestamp = null;

          // Convert Firebase data to points array
          for (const timestamp in data) {
            // Skip sessionData and other non-point entries
            if (timestamp === "sessionData" || !data[timestamp].timestamp) {
              continue;
            }
            
            const point = data[timestamp];
            points.push(point);
            
            // Track the earliest (first) entry
            const pointTime = new Date(point.timestamp).getTime();
            if (earliestTimestamp === null || pointTime < earliestTimestamp) {
              earliestTimestamp = pointTime;
            }
          }

          // Sort points by timestamp (newest first)
          points.sort((a, b) => {
            const timeA = new Date(a.timestamp).getTime();
            const timeB = new Date(b.timestamp).getTime();
            return timeB - timeA; // Descending order (newest first)
          });

          // Set session state
          isExistingSession = true;
          firstEntryTimestamp = earliestTimestamp;
          collectedPoints = points;
          
          // Check if still within edit window
          const now = Date.now();
          const elapsed = now - firstEntryTimestamp;
          canEdit = elapsed < EDIT_TIME_LIMIT;
          
          updatePointsList();
          redrawAllFigures();
          
          // Load session notes, confidence, and questionnaire
          if (data.sessionData) {
            sessionNotes = data.sessionData.notes || "";
            sessionConfidence = data.sessionData.confidence || 0;
            questionnaireResponses = data.sessionData.questionnaire || {
              q1: null,
              q2: null,
              q3: null,
              q4: null
            };
            updateNotesDisplay();
            updateQuestionnaireDisplay();
          } else {
            resetNotes();
            resetQuestionnaire();
          }
          
          updateEditStatus();
          startEditStatusTimer();
          updateNotesEditability();
          updateQuestionnaireEditability();
          
          return true;
        }
      } catch (error) {
        console.error("Error loading participant data:", error);
      }
      
      return false;
    }

    function updateEditStatus() {
      if (!isExistingSession) {
        idStatusEl.textContent = "✓ ID is valid";
        idStatusEl.className = "id-status id-valid";
        return;
      }

      if (canEdit) {
        const elapsed = Date.now() - firstEntryTimestamp;
        const remaining = EDIT_TIME_LIMIT - elapsed;
        
        // Check if time limit just expired
        if (remaining <= 0) {
          canEdit = false;
          idStatusEl.textContent = "❌ Edit time limit expired (1 hour)";
          idStatusEl.className = "id-status id-invalid";
          return;
        }
        
        const minutesRemaining = Math.ceil(remaining / 60000);
        idStatusEl.textContent = `✓ Editing enabled (${minutesRemaining} min remaining)`;
        idStatusEl.className = "id-status id-valid";
      } else {
        idStatusEl.textContent = "❌ Edit time limit expired (1 hour)";
        idStatusEl.className = "id-status id-invalid";
      }
    }

    let editStatusTimer = null;
    
    function startEditStatusTimer() {
      // Update every 30 seconds to show countdown
      if (editStatusTimer) clearInterval(editStatusTimer);
      editStatusTimer = setInterval(() => {
        if (isExistingSession) {
          updateEditStatus();
        }
      }, 30000); // Update every 30 seconds
    }

    function stopEditStatusTimer() {
      if (editStatusTimer) {
        clearInterval(editStatusTimer);
        editStatusTimer = null;
      }
    }

    function resetNotes() {
      sessionNotes = "";
      sessionConfidence = 0;
      notesTextarea.value = "";
      charCountEl.textContent = "0";
      confidenceLabel.textContent = "(Not rated)";
      document.querySelectorAll(".star").forEach(star => star.classList.remove("active"));
      lastSavedEl.textContent = "";
    }

    function updateNotesDisplay() {
      notesTextarea.value = sessionNotes;
      charCountEl.textContent = sessionNotes.length;
      updateStarsDisplay();
      updateNotesEditability();
    }

    function updateStarsDisplay() {
      document.querySelectorAll(".star").forEach(star => {
        const value = parseInt(star.dataset.value);
        if (value <= sessionConfidence) {
          star.classList.add("active");
        } else {
          star.classList.remove("active");
        }
      });

      const labels = {
        0: "(Not rated)",
        1: "Not confident",
        2: "Somewhat confident",
        3: "Moderately confident",
        4: "Confident",
        5: "Very confident"
      };
      confidenceLabel.textContent = labels[sessionConfidence] || "(Not rated)";
    }

    function updateNotesEditability() {
      const disabled = isExistingSession && !canEdit;
      notesTextarea.disabled = disabled;
      document.querySelectorAll(".star").forEach(star => {
        if (disabled) {
          star.style.pointerEvents = "none";
          star.style.opacity = "0.5";
        } else {
          star.style.pointerEvents = "auto";
          star.style.opacity = "1";
        }
      });
    }

    function updateCharCounter() {
      charCountEl.textContent = notesTextarea.value.length;
    }

    // Notes event listeners
    notesTextarea.addEventListener("input", (e) => {
      updateCharCounter();
      // Note: No auto-save. Data saved on "Save and Send" click
    });

    document.querySelectorAll(".star").forEach(star => {
      star.addEventListener("click", (e) => {
        if (isExistingSession && !canEdit) return;
        
        sessionConfidence = parseInt(e.target.dataset.value);
        updateStarsDisplay();
        // Note: No auto-save. Data saved on "Save and Send" click
      });

      star.addEventListener("mouseover", (e) => {
        const value = parseInt(e.target.dataset.value);
        document.querySelectorAll(".star").forEach(s => {
          if (parseInt(s.dataset.value) <= value) {
            s.style.color = "#ffc107";
          } else {
            s.style.color = "#ddd";
          }
        });
      });
    });

    starRating.addEventListener("mouseleave", () => {
      updateStarsDisplay();
    });

    // ===== QUESTIONNAIRE FUNCTIONS =====
    function resetQuestionnaire() {
      questionnaireResponses = {
        q1: null,
        q2: null,
        q3: null,
        q4: null
      };
      // Uncheck all radio buttons
      Object.values(questionnaireRadios).forEach(radios => {
        radios.forEach(radio => radio.checked = false);
      });
      qLastSavedEl.textContent = "";
      updateQuestionnaireEditability();
    }

    function updateQuestionnaireDisplay() {
      // Set radio buttons based on stored responses
      Object.entries(questionnaireResponses).forEach(([key, value]) => {
        if (value !== null) {
          const radio = document.querySelector(`input[name="${key}"][value="${value}"]`);
          if (radio) radio.checked = true;
        }
      });
      updateQuestionnaireEditability();
    }

    function updateQuestionnaireEditability() {
      const disabled = isExistingSession && !canEdit;
      Object.values(questionnaireRadios).forEach(radios => {
        radios.forEach(radio => {
          radio.disabled = disabled;
        });
      });
    }


    // Questionnaire event listeners
    Object.entries(questionnaireRadios).forEach(([key, radios]) => {
      radios.forEach(radio => {
        radio.addEventListener("change", (e) => {
          if (isExistingSession && !canEdit) return;
          questionnaireResponses[key] = parseInt(e.target.value);
          // Note: No auto-save. Data saved on "Save and Send" click
        });
      });
    });

    function getFilteredPoints() {
      if (displayFilter === "all") {
        return collectedPoints;
      } else if (displayFilter === "touched") {
        return collectedPoints.filter(point => point.direction === "touched");
      } else if (displayFilter === "touched_by") {
        return collectedPoints.filter(point => point.direction === "touched_by");
      }
      return collectedPoints;
    }

    function redrawAllFigures() {
      figureConfigs.forEach(redrawFigure);
    }

    async function updateIdStatus() {
      const id = participantInput.value.trim();

      if (!id) {
        idIsValid = false;
        idStatusEl.textContent = "";
        idStatusEl.className = "id-status";
        return;
      }

      if (!isValidNumericId(id)) {
        idIsValid = false;
        idStatusEl.textContent = "❌ ID must be a number (digits only)";
        idStatusEl.className = "id-status id-invalid";
        return;
      }

      idIsValid = true;
      idStatusEl.textContent = "✓ ID is valid";
      idStatusEl.className = "id-status id-valid";
      
      // Check combined key validity if name is also present
      updateCombinedKeyStatus();
    }

    async function updateNameStatus() {
      const name = participantNameInput.value.trim();

      if (!name) {
        nameIsValid = false;
        nameStatusEl.textContent = "";
        nameStatusEl.className = "id-status";
        return;
      }

      nameIsValid = true;
      nameStatusEl.textContent = "✓ Name is valid";
      nameStatusEl.className = "id-status id-valid";
      
      // Check combined key validity if ID is also present
      updateCombinedKeyStatus();
    }

    async function updateCombinedKeyStatus() {
      const id = participantInput.value.trim();
      const name = participantNameInput.value.trim();
      
      if (!idIsValid || !nameIsValid) {
        return;
      }

      // Try to load existing participant data
      const dataExists = await loadExistingParticipantData(id, name);
      
      if (!dataExists) {
        // New session - reset state
        stopEditStatusTimer();
        isExistingSession = false;
        firstEntryTimestamp = null;
        canEdit = true;
        collectedPoints = [];
        updatePointsList();
        redrawAllFigures();
        resetNotes();
        resetQuestionnaire();
        updateNotesEditability();
        updateQuestionnaireEditability();
        idStatusEl.textContent = "✓ ID is valid (New session)";
        idStatusEl.className = "id-status id-valid";
      }
    }

    participantInput.addEventListener("input", updateIdStatus);
    participantNameInput.addEventListener("input", updateNameStatus);

    // Marking mode event listeners
    markingModeRadios.forEach(radio => {
      radio.addEventListener("change", (e) => {
        markingMode = e.target.value;
        
        // Update recording direction and display filter based on marking mode
        if (markingMode === "mark_touched_by") {
          currentDirection = "touched_by";
          displayFilter = "touched_by"; // Show what you just recorded (red)
        } else if (markingMode === "mark_touched") {
          currentDirection = "touched";
          displayFilter = "touched"; // Show what you just recorded (blue)
        } else if (markingMode === "view_all") {
          displayFilter = "all"; // Show all points
        }
        
        updatePointsList();
        redrawAllFigures();
        setStatus(`Mode: ${e.target.parentElement.textContent.split('(')[0].trim()}`);
      });
    });

    function setStatus(message) {
      statusEl.childNodes[0].textContent = message;
    }

    function setSyncStatus(status) {
      syncIndicator.className = "sync-indicator";
      if (status) {
        syncIndicator.classList.add(status);
      }
    }

    // Show confidence modal
    async function sendToFirebase(point) {
      try {
        setSyncStatus("syncing");
        const participantKey = getParticipantKey(point.participantId, point.participantName);
        const timestamp = Date.now();
        
        await db.ref(`data/${participantKey}/${timestamp}`).set(point);
        
        setSyncStatus("synced");
        setTimeout(() => setSyncStatus(null), 2000);
      } catch (error) {
        console.error("Firebase error:", error);
        setSyncStatus("error");
        setStatus(`Error syncing to server. Data saved locally.`);
      }
    }

    function savePoint(point) {
      // Insert new point at the beginning (unshift) to keep newest first
      collectedPoints.unshift(point);
      sendToFirebase(point);
      updatePointsList();
      const directionLabel = point.direction === "touched_by" ? "was touched" : "touched";
      setStatus(
        `Recorded: ${point.figure} (${directionLabel}). Total: ${collectedPoints.length}`
      );
    }

    function updatePointsList() {
      if (collectedPoints.length === 0) {
        pointsListEl.innerHTML = '<div class="empty-list">No points recorded yet</div>';
        return;
      }

      // Create filtered list with original indices
      const filteredWithIndices = collectedPoints
        .map((point, index) => ({ point, index }))
        .reverse() // Reverse to show newest first
        .filter(({ point }) => {
          if (displayFilter === "all") return true;
          if (displayFilter === "touched") return point.direction === "touched";
          if (displayFilter === "touched_by") return point.direction === "touched_by";
          return true;
        });

      if (filteredWithIndices.length === 0) {
        pointsListEl.innerHTML = '<div class="empty-list">No points match current filter</div>';
        return;
      }

      pointsListEl.innerHTML = filteredWithIndices.map(({ point, index }) => {
        const directionLabel = point.direction === "touched_by" ? "I was touched" : "I touched";
        return `
        <div class="point-item">
          <div class="point-color" style="background: ${directionColors[point.direction]}"></div>
          <div class="point-info">
            <strong>${point.figure}</strong> - <strong>${directionLabel}</strong>
          </div>
          <button class="point-delete-btn" onclick="deletePoint(${index})">Delete</button>
        </div>
      `;
      }).join("");
    }

    function deletePoint(index) {
      if (isExistingSession && !canEdit) {
        setStatus("❌ Edit time limit expired. Cannot delete points.");
        return;
      }

      collectedPoints.splice(index, 1);
      updatePointsList();
      setStatus(`Deleted point. Total: ${collectedPoints.length}`);
      
      // Redraw all figures to remove the deleted marker
      figureConfigs.forEach(redrawFigure);
    }

    function redrawFigure(figureConfig) {
      const canvas = document.getElementById(figureConfig.canvasId);
      const ctx = canvas.getContext("2d");
      const img = new Image();
      img.src = figureConfig.imageSrc;

      img.onload = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        
        // Redraw filtered markers for this figure
        const filteredPoints = getFilteredPoints();
        for (const point of filteredPoints) {
          if (point.figure === figureConfig.id) {
            drawMarker(
              ctx,
              point.xNorm * canvas.width,
              point.yNorm * canvas.height,
              directionColors[point.direction]
            );
          }
        }
      };
    }

    function setupFigure(figureConfig) {
      const canvas = document.getElementById(figureConfig.canvasId);
      const ctx = canvas.getContext("2d");
      const img = new Image();
      img.src = figureConfig.imageSrc;

      img.onload = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      };

      function recordPoint(clientX, clientY) {
        if (!idIsValid || !nameIsValid) {
          console.warn("Invalid ID or name:", { idIsValid, nameIsValid });
          setStatus("❌ Invalid ID or name. Cannot record points.");
          return;
        }

        if (markingMode === "view_all") {
          setStatus("⚠️ Viewing mode. Switch to 'Mark' mode to record points.");
          return;
        }

        if (isExistingSession && !canEdit) {
          setStatus("❌ Edit time limit expired (1 hour). Cannot add more points.");
          return;
        }

        const rect = canvas.getBoundingClientRect();
        const xPx = clientX - rect.left;
        const yPx = clientY - rect.top;

        if (xPx < 0 || xPx > rect.width || yPx < 0 || yPx > rect.height) {
          console.log("Click outside canvas bounds");
          return;
        }

        const xNorm = xPx / rect.width;
        const yNorm = yPx / rect.height;

        // Use current marking mode direction
        const direction = currentDirection;
        
        console.log("Recording point:", { 
          figure: figureConfig.id, 
          direction, 
          xNorm: xNorm.toFixed(2), 
          yNorm: yNorm.toFixed(2) 
        });

        // Create point and save immediately
        const point = {
          participantId: participantInput.value.trim(),
          participantName: participantNameInput.value.trim(),
          figure: figureConfig.id,
          direction: direction,
          xNorm: xNorm,
          yNorm: yNorm,
          timestamp: new Date().toISOString()
        };

        savePoint(point);
        redrawFigure(figureConfig);
      }

      function handleClick(event) {
        recordPoint(event.clientX, event.clientY);
      }

      // Touch tracking variables
      let touchStartX = 0;
      let touchStartY = 0;
      let isTouchMoving = false;
      const TOUCH_MOVE_THRESHOLD = 10; // pixels

      function handleTouchStart(event) {
        // Only handle single touch (not multi-touch scroll/pinch)
        if (event.touches.length > 1) {
          return; // Ignore multi-touch
        }
        
        const touch = event.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        isTouchMoving = false;
      }

      function handleTouchMove(event) {
        if (event.touches.length > 1) {
          return; // Multi-touch, allow scrolling
        }

        const touch = event.touches[0];
        const moveX = Math.abs(touch.clientX - touchStartX);
        const moveY = Math.abs(touch.clientY - touchStartY);

        if (moveX > TOUCH_MOVE_THRESHOLD || moveY > TOUCH_MOVE_THRESHOLD) {
          isTouchMoving = true; // User is scrolling, not tapping
        }
      }

      function handleTouchEnd(event) {
        if (event.touches.length > 0) {
          return; // Other touches still active
        }

        // Only record if it wasn't a scroll/drag
        if (!isTouchMoving) {
          const touch = event.changedTouches[0];
          recordPoint(touch.clientX, touch.clientY);
        }

        isTouchMoving = false;
      }

      canvas.addEventListener("click", handleClick);
      canvas.addEventListener("touchstart", handleTouchStart, { passive: true });
      canvas.addEventListener("touchmove", handleTouchMove, { passive: true });
      canvas.addEventListener("touchend", handleTouchEnd, { passive: true });
      
      // Prevent default scroll/zoom behavior on canvas (only for wheel)
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
      }, { passive: false });
    }

    function drawMarker(ctx, x, y, color) {
      const radius = 5;
      ctx.save();
      ctx.fillStyle = color;
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function downloadFile(filename, mimeType, content) {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function downloadAsJson() {
      if (collectedPoints.length === 0) {
        alert("No points recorded yet.");
        return;
      }
      const participantId = participantInput.value.trim() || "unknown";
      const filename = `body_map_${participantId}_${Date.now()}.json`;
      downloadFile(filename, "application/json", JSON.stringify(collectedPoints, null, 2));
    }

    function clearPoints() {
      if (confirm("Are you sure you want to delete ALL points?")) {
        collectedPoints.length = 0;
        updatePointsList();
        setStatus("Cleared all points for this session.");
        figureConfigs.forEach(redrawFigure);
      }
    }

    // document.getElementById("downloadJson").addEventListener("click", downloadAsJson);
    document.getElementById("clearPoints").addEventListener("click", clearPoints);

    // Initialize
    loadExistingIds();
    figureConfigs.forEach(setupFigure);
    setStatus("Ready. Click or tap to mark contact.");

    // Save all session data and points, then reload
    window.saveAllAndReload = async function() {
      const btn = document.getElementById('saveAndSend');

      if (!idIsValid || !nameIsValid) {
        alert('Participant ID and Name must be valid before saving.');
        return;
      }

      // Pre-save validation: ensure at least one point for each direction and questionnaire answered
      const hasTouched = collectedPoints.some(p => p.direction === 'touched');
      const hasTouchedBy = collectedPoints.some(p => p.direction === 'touched_by');
      const unanswered = Object.entries(questionnaireResponses)
        .filter(([_, v]) => v === null)
        .map(([k]) => k.toUpperCase());

      const missing = [];
      if (!hasTouched) missing.push('No points recorded for "I touched".');
      if (!hasTouchedBy) missing.push('No points recorded for "I was touched".');
      if (unanswered.length) missing.push(`Unanswered questionnaire items: ${unanswered.join(', ')}`);

      if (missing.length) {
        alert(missing.join('\n') + '\n\nPlease complete before saving.');
        return;
      }

      let prevText = 'Save and Send';
      try {
        if (btn) {
          btn.disabled = true;
          prevText = btn.textContent;
          btn.textContent = 'Saving...';
        }

        setSyncStatus('syncing');

        const key = getParticipantKey(participantInput.value.trim(), participantNameInput.value.trim());

        // Session metadata
        const sessionData = {
          notes: notesTextarea.value,
          confidence: sessionConfidence,
          questionnaire: questionnaireResponses,
          lastEdited: new Date().toISOString()
        };

        // Save sessionData
        await db.ref(`data/${key}/sessionData`).set(sessionData);

        // Save all collected points as a single node to ensure current state is stored
        await db.ref(`data/${key}/sessionPoints`).set(collectedPoints);

        setSyncStatus('synced');

        // Show a completion message, then clear sync indicator and reload
        try {
          setStatus('Save successful');
          alert('All data are saved. Thank you for your participation.');
        } finally {
          setSyncStatus(null);
          location.reload();
        }
      } catch (error) {
        console.error('Error saving before reload:', error);
        setSyncStatus('error');
        alert('Error saving data. See console for details.');
        if (btn) {
          btn.disabled = false;
          btn.textContent = prevText || 'Save and Send';
        }
      }
    };
  </script>

  <div style="text-align: center; margin: 2rem 0;">
    <button id="saveAndSend" type="button" class="secondary" onclick="saveAllAndReload()">Save and Send</button>
  </div>
</body>
</html>
